# 档案管理系统 - 后端开发规范文档

## 1. 文档概述

### 1.1 文档目的
本文档旨在为档案管理系统后端开发提供统一的开发规范、技术标准和最佳实践，确保代码质量、系统性能和可维护性。

### 1.2 适用范围
- 后端开发工程师
- 技术负责人
- 代码审查人员
- 系统架构师

### 1.3 技术栈概览
- **框架**: Spring Boot 3.2.x
- **安全**: Spring Security 6.x
- **数据访问**: Spring Data JPA 3.x
- **数据库**: MySQL 8.0+
- **缓存**: Redis 7.x
- **文件存储**: MinIO
- **消息队列**: RabbitMQ 3.12+
- **构建工具**: Maven 3.9+
- **JDK版本**: OpenJDK 17+

## 2. 项目结构规范

### 2.1 标准项目结构
```
archive-management-system/
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── company/
│   │   │           └── archive/
│   │   │               ├── ArchiveManagementApplication.java
│   │   │               ├── config/          # 配置类
│   │   │               │   ├── SecurityConfig.java
│   │   │               │   ├── RedisConfig.java
│   │   │               │   ├── MinioConfig.java
│   │   │               │   └── RabbitMQConfig.java
│   │   │               ├── controller/      # 控制器层
│   │   │               │   ├── UserController.java
│   │   │               │   ├── ArchiveController.java
│   │   │               │   └── BorrowController.java
│   │   │               ├── service/         # 业务逻辑层
│   │   │               │   ├── UserService.java
│   │   │               │   ├── ArchiveService.java
│   │   │               │   └── impl/
│   │   │               │       ├── UserServiceImpl.java
│   │   │               │       └── ArchiveServiceImpl.java
│   │   │               ├── repository/      # 数据访问层
│   │   │               │   ├── UserRepository.java
│   │   │               │   └── ArchiveRepository.java
│   │   │               ├── entity/          # 实体类
│   │   │               │   ├── User.java
│   │   │               │   ├── Archive.java
│   │   │               │   └── BorrowRecord.java
│   │   │               ├── dto/             # 数据传输对象
│   │   │               │   ├── request/
│   │   │               │   │   ├── UserCreateRequest.java
│   │   │               │   │   └── ArchiveCreateRequest.java
│   │   │               │   └── response/
│   │   │               │       ├── UserResponse.java
│   │   │               │       └── ArchiveResponse.java
│   │   │               ├── common/          # 公共组件
│   │   │               │   ├── constant/    # 常量定义
│   │   │               │   ├── enums/       # 枚举类
│   │   │               │   ├── exception/   # 异常处理
│   │   │               │   └── util/        # 工具类
│   │   │               ├── security/        # 安全相关
│   │   │               │   ├── JwtTokenProvider.java
│   │   │               │   ├── UserDetailsServiceImpl.java
│   │   │               │   └── SecurityUtils.java
│   │   │               └── aspect/          # 切面编程
│   │   │                   ├── LoggingAspect.java
│   │   │                   └── PermissionAspect.java
│   │   └── resources/
│   │       ├── application.yml
│   │       ├── application-dev.yml
│   │       ├── application-prod.yml
│   │       ├── db/
│   │       │   └── migration/
│   │       │       ├── V1__Create_user_table.sql
│   │       │       └── V2__Create_archive_table.sql
│   │       └── static/
│   └── test/
│       └── java/
│           └── com/
│               └── company/
│                   └── archive/
│                       ├── controller/
│                       ├── service/
│                       └── repository/
├── pom.xml
├── Dockerfile
├── docker-compose.yml
└── README.md
```

### 2.2 包命名规范
- **基础包名**: `com.company.archive`
- **控制器**: `controller`
- **服务层**: `service` 和 `service.impl`
- **数据访问**: `repository`
- **实体类**: `entity`
- **DTO**: `dto.request` 和 `dto.response`
- **配置类**: `config`
- **工具类**: `common.util`
- **常量**: `common.constant`
- **枚举**: `common.enums`
- **异常**: `common.exception`

## 3. 代码规范

### 3.1 命名规范
```java
// 类名：大驼峰命名法
public class ArchiveService {}

// 方法名：小驼峰命名法
public void createArchive() {}

// 变量名：小驼峰命名法
private String archiveTitle;

// 常量：全大写，下划线分隔
public static final String DEFAULT_STATUS = "ACTIVE";

// 包名：全小写，点分隔
package com.company.archive.service;
```

### 3.2 注释规范
```java
/**
 * 档案管理服务类
 * 
 * @author 开发者姓名
 * @since 2025-01-22
 */
@Service
public class ArchiveService {
    
    /**
     * 创建档案
     * 
     * @param request 档案创建请求
     * @return 创建的档案信息
     * @throws ArchiveException 档案创建异常
     */
    public ArchiveResponse createArchive(ArchiveCreateRequest request) {
        // 业务逻辑实现
    }
}
```

### 3.3 异常处理规范
```java
// 自定义业务异常
@ResponseStatus(HttpStatus.BAD_REQUEST)
public class ArchiveException extends RuntimeException {
    private final String errorCode;
    
    public ArchiveException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
}

// 全局异常处理器
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(ArchiveException.class)
    public ResponseEntity<ErrorResponse> handleArchiveException(ArchiveException e) {
        ErrorResponse error = ErrorResponse.builder()
            .code(e.getErrorCode())
            .message(e.getMessage())
            .timestamp(LocalDateTime.now())
            .build();
        return ResponseEntity.badRequest().body(error);
    }
}
```

## 4. 数据访问层规范

### 4.1 实体类设计
```java
@Entity
@Table(name = "archives")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class Archive {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "archive_no", unique = true, nullable = false, length = 50)
    private String archiveNo;
    
    @Column(name = "title", nullable = false, length = 200)
    private String title;
    
    @Enumerated(EnumType.STRING)
    @Column(name = "status", nullable = false)
    private ArchiveStatus status;
    
    @Column(name = "security_level", nullable = false)
    private SecurityLevel securityLevel;
    
    @CreationTimestamp
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
    
    @Version
    private Long version;
}
```

### 4.2 Repository接口规范
```java
@Repository
public interface ArchiveRepository extends JpaRepository<Archive, Long>, JpaSpecificationExecutor<Archive> {
    
    /**
     * 根据档案编号查找档案
     */
    Optional<Archive> findByArchiveNo(String archiveNo);
    
    /**
     * 根据状态和安全级别查找档案
     */
    @Query("SELECT a FROM Archive a WHERE a.status = :status AND a.securityLevel = :securityLevel")
    List<Archive> findByStatusAndSecurityLevel(@Param("status") ArchiveStatus status, 
                                             @Param("securityLevel") SecurityLevel securityLevel);
    
    /**
     * 分页查询档案
     */
    @Query(value = "SELECT * FROM archives WHERE title LIKE %:keyword% ORDER BY created_at DESC",
           countQuery = "SELECT count(*) FROM archives WHERE title LIKE %:keyword%",
           nativeQuery = true)
    Page<Archive> findByTitleContaining(@Param("keyword") String keyword, Pageable pageable);
}
```

### 4.3 数据库事务管理
```java
@Service
@Transactional(readOnly = true)
public class ArchiveServiceImpl implements ArchiveService {
    
    @Transactional(rollbackFor = Exception.class)
    public ArchiveResponse createArchive(ArchiveCreateRequest request) {
        // 事务性操作
        Archive archive = Archive.builder()
            .title(request.getTitle())
            .status(ArchiveStatus.PENDING)
            .build();
        
        Archive saved = archiveRepository.save(archive);
        
        // 发送异步消息
        messageProducer.sendArchiveCreatedMessage(saved.getId());
        
        return ArchiveResponse.from(saved);
    }
}
```

## 5. 业务逻辑层规范

### 5.1 Service接口设计
```java
public interface ArchiveService {
    
    /**
     * 创建档案
     */
    ArchiveResponse createArchive(ArchiveCreateRequest request);
    
    /**
     * 更新档案
     */
    ArchiveResponse updateArchive(Long id, ArchiveUpdateRequest request);
    
    /**
     * 删除档案
     */
    void deleteArchive(Long id);
    
    /**
     * 分页查询档案
     */
    PageResponse<ArchiveResponse> searchArchives(ArchiveSearchRequest request, Pageable pageable);
}
```

### 5.2 Service实现规范
```java
@Service
@Slf4j
@RequiredArgsConstructor
public class ArchiveServiceImpl implements ArchiveService {
    
    private final ArchiveRepository archiveRepository;
    private final FileStorageService fileStorageService;
    private final CacheService cacheService;
    private final MessageProducer messageProducer;
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public ArchiveResponse createArchive(ArchiveCreateRequest request) {
        log.info("Creating archive with title: {}", request.getTitle());
        
        // 参数校验
        validateCreateRequest(request);
        
        // 业务逻辑处理
        Archive archive = buildArchiveFromRequest(request);
        Archive saved = archiveRepository.save(archive);
        
        // 缓存更新
        cacheService.evictArchiveCache();
        
        // 异步处理
        messageProducer.sendArchiveCreatedMessage(saved.getId());
        
        log.info("Archive created successfully with id: {}", saved.getId());
        return ArchiveResponse.from(saved);
    }
    
    private void validateCreateRequest(ArchiveCreateRequest request) {
        if (StringUtils.isBlank(request.getTitle())) {
            throw new ArchiveException("INVALID_TITLE", "档案标题不能为空");
        }
        // 其他校验逻辑
    }
}
```

## 6. 控制器层规范

### 6.1 Controller设计规范
```java
@RestController
@RequestMapping("/api/v1/archives")
@Slf4j
@RequiredArgsConstructor
@Validated
public class ArchiveController {
    
    private final ArchiveService archiveService;
    
    @PostMapping
    @PreAuthorize("hasRole('ARCHIVE_MANAGER')")
    public ResponseEntity<ApiResponse<ArchiveResponse>> createArchive(
            @Valid @RequestBody ArchiveCreateRequest request) {
        
        log.info("Received create archive request: {}", request.getTitle());
        
        ArchiveResponse response = archiveService.createArchive(request);
        
        return ResponseEntity.ok(ApiResponse.success(response));
    }
    
    @GetMapping("/{id}")
    @PreAuthorize("hasPermission(#id, 'Archive', 'READ')")
    public ResponseEntity<ApiResponse<ArchiveResponse>> getArchive(@PathVariable Long id) {
        ArchiveResponse response = archiveService.getArchive(id);
        return ResponseEntity.ok(ApiResponse.success(response));
    }
    
    @GetMapping
    public ResponseEntity<ApiResponse<PageResponse<ArchiveResponse>>> searchArchives(
            @Valid ArchiveSearchRequest request,
            @PageableDefault(size = 20, sort = "createdAt", direction = Sort.Direction.DESC) Pageable pageable) {
        
        PageResponse<ArchiveResponse> response = archiveService.searchArchives(request, pageable);
        return ResponseEntity.ok(ApiResponse.success(response));
    }
}
```

### 6.2 统一响应格式
```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ApiResponse<T> {
    private boolean success;
    private String message;
    private T data;
    private String errorCode;
    private LocalDateTime timestamp;
    
    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
            .success(true)
            .data(data)
            .timestamp(LocalDateTime.now())
            .build();
    }
    
    public static <T> ApiResponse<T> error(String errorCode, String message) {
        return ApiResponse.<T>builder()
            .success(false)
            .errorCode(errorCode)
            .message(message)
            .timestamp(LocalDateTime.now())
            .build();
    }
}
```

## 7. 安全认证规范

### 7.1 JWT配置
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfig {
    
    private final JwtAuthenticationEntryPoint jwtAuthenticationEntryPoint;
    private final JwtAccessDeniedHandler jwtAccessDeniedHandler;
    private final JwtTokenProvider jwtTokenProvider;
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/v1/auth/**").permitAll()
                .requestMatchers("/api/v1/public/**").permitAll()
                .anyRequest().authenticated()
            )
            .exceptionHandling(ex -> ex
                .authenticationEntryPoint(jwtAuthenticationEntryPoint)
                .accessDeniedHandler(jwtAccessDeniedHandler)
            )
            .addFilterBefore(new JwtAuthenticationFilter(jwtTokenProvider), 
                           UsernamePasswordAuthenticationFilter.class)
            .build();
    }
}
```

### 7.2 权限控制
```java
@Component
@RequiredArgsConstructor
public class PermissionEvaluator implements org.springframework.security.access.PermissionEvaluator {
    
    private final UserService userService;
    private final ArchiveService archiveService;
    
    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        if (authentication == null || !authentication.isAuthenticated()) {
            return false;
        }
        
        String username = authentication.getName();
        String permissionStr = permission.toString();
        
        // 根据业务逻辑判断权限
        return checkPermission(username, targetDomainObject, permissionStr);
    }
    
    private boolean checkPermission(String username, Object target, String permission) {
        // 权限检查逻辑
        return true;
    }
}
```

## 8. 缓存策略

### 8.1 Redis配置
```java
@Configuration
@EnableCaching
public class RedisConfig {
    
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(connectionFactory);
        
        // 设置序列化器
        template.setKeySerializer(new StringRedisSerializer());
        template.setValueSerializer(new GenericJackson2JsonRedisSerializer());
        template.setHashKeySerializer(new StringRedisSerializer());
        template.setHashValueSerializer(new GenericJackson2JsonRedisSerializer());
        
        return template;
    }
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory connectionFactory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(connectionFactory)
            .cacheDefaults(config)
            .build();
    }
}
```

### 8.2 缓存使用规范
```java
@Service
public class ArchiveServiceImpl implements ArchiveService {
    
    @Cacheable(value = "archives", key = "#id")
    public ArchiveResponse getArchive(Long id) {
        Archive archive = archiveRepository.findById(id)
            .orElseThrow(() -> new ArchiveNotFoundException("档案不存在"));
        return ArchiveResponse.from(archive);
    }
    
    @CacheEvict(value = "archives", key = "#id")
    public ArchiveResponse updateArchive(Long id, ArchiveUpdateRequest request) {
        // 更新逻辑
    }
    
    @CacheEvict(value = "archives", allEntries = true)
    public void clearArchiveCache() {
        // 清除所有档案缓存
    }
}
```

## 9. 文件存储规范

### 9.1 MinIO配置
```java
@Configuration
@ConfigurationProperties(prefix = "minio")
@Data
public class MinioConfig {
    private String endpoint;
    private String accessKey;
    private String secretKey;
    private String bucketName;
    
    @Bean
    public MinioClient minioClient() {
        return MinioClient.builder()
            .endpoint(endpoint)
            .credentials(accessKey, secretKey)
            .build();
    }
}
```

### 9.2 文件服务实现
```java
@Service
@RequiredArgsConstructor
@Slf4j
public class FileStorageService {
    
    private final MinioClient minioClient;
    private final MinioConfig minioConfig;
    
    public String uploadFile(MultipartFile file, String folder) {
        try {
            String fileName = generateFileName(file.getOriginalFilename());
            String objectName = folder + "/" + fileName;
            
            minioClient.putObject(
                PutObjectArgs.builder()
                    .bucket(minioConfig.getBucketName())
                    .object(objectName)
                    .stream(file.getInputStream(), file.getSize(), -1)
                    .contentType(file.getContentType())
                    .build()
            );
            
            return objectName;
        } catch (Exception e) {
            log.error("文件上传失败", e);
            throw new FileStorageException("文件上传失败");
        }
    }
    
    public InputStream downloadFile(String objectName) {
        try {
            return minioClient.getObject(
                GetObjectArgs.builder()
                    .bucket(minioConfig.getBucketName())
                    .object(objectName)
                    .build()
            );
        } catch (Exception e) {
            log.error("文件下载失败", e);
            throw new FileStorageException("文件下载失败");
        }
    }
    
    private String generateFileName(String originalFilename) {
        String extension = FilenameUtils.getExtension(originalFilename);
        return UUID.randomUUID().toString() + "." + extension;
    }
}
```

## 10. 消息队列规范

### 10.1 RabbitMQ配置
```java
@Configuration
@EnableRabbit
public class RabbitMQConfig {
    
    public static final String ARCHIVE_EXCHANGE = "archive.exchange";
    public static final String ARCHIVE_CREATED_QUEUE = "archive.created.queue";
    public static final String ARCHIVE_CREATED_ROUTING_KEY = "archive.created";
    
    @Bean
    public TopicExchange archiveExchange() {
        return new TopicExchange(ARCHIVE_EXCHANGE);
    }
    
    @Bean
    public Queue archiveCreatedQueue() {
        return QueueBuilder.durable(ARCHIVE_CREATED_QUEUE).build();
    }
    
    @Bean
    public Binding archiveCreatedBinding() {
        return BindingBuilder
            .bind(archiveCreatedQueue())
            .to(archiveExchange())
            .with(ARCHIVE_CREATED_ROUTING_KEY);
    }
}
```

### 10.2 消息生产者
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class MessageProducer {
    
    private final RabbitTemplate rabbitTemplate;
    
    public void sendArchiveCreatedMessage(Long archiveId) {
        ArchiveCreatedMessage message = ArchiveCreatedMessage.builder()
            .archiveId(archiveId)
            .timestamp(LocalDateTime.now())
            .build();
        
        rabbitTemplate.convertAndSend(
            RabbitMQConfig.ARCHIVE_EXCHANGE,
            RabbitMQConfig.ARCHIVE_CREATED_ROUTING_KEY,
            message
        );
        
        log.info("发送档案创建消息: {}", archiveId);
    }
}
```

### 10.3 消息消费者
```java
@Component
@RequiredArgsConstructor
@Slf4j
public class MessageConsumer {
    
    private final NotificationService notificationService;
    
    @RabbitListener(queues = RabbitMQConfig.ARCHIVE_CREATED_QUEUE)
    public void handleArchiveCreated(ArchiveCreatedMessage message) {
        log.info("处理档案创建消息: {}", message.getArchiveId());
        
        try {
            // 发送通知
            notificationService.sendArchiveCreatedNotification(message.getArchiveId());
        } catch (Exception e) {
            log.error("处理档案创建消息失败", e);
            throw new MessageProcessingException("消息处理失败");
        }
    }
}
```

## 11. 日志规范

### 11.1 日志配置
```yaml
logging:
  level:
    com.company.archive: INFO
    org.springframework.security: DEBUG
    org.hibernate.SQL: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
  file:
    name: logs/archive-management.log
    max-size: 100MB
    max-history: 30
```

### 11.2 日志使用规范
```java
@Service
@Slf4j
public class ArchiveServiceImpl implements ArchiveService {
    
    public ArchiveResponse createArchive(ArchiveCreateRequest request) {
        // 记录关键业务操作
        log.info("开始创建档案, 标题: {}, 操作人: {}", 
                request.getTitle(), SecurityUtils.getCurrentUsername());
        
        try {
            // 业务逻辑
            Archive archive = processArchiveCreation(request);
            
            log.info("档案创建成功, ID: {}, 编号: {}", 
                    archive.getId(), archive.getArchiveNo());
            
            return ArchiveResponse.from(archive);
        } catch (Exception e) {
            log.error("档案创建失败, 标题: {}, 错误: {}", 
                     request.getTitle(), e.getMessage(), e);
            throw e;
        }
    }
}
```

## 12. 测试规范

### 12.1 单元测试
```java
@ExtendWith(MockitoExtension.class)
class ArchiveServiceImplTest {
    
    @Mock
    private ArchiveRepository archiveRepository;
    
    @Mock
    private FileStorageService fileStorageService;
    
    @InjectMocks
    private ArchiveServiceImpl archiveService;
    
    @Test
    @DisplayName("创建档案 - 成功")
    void createArchive_Success() {
        // Given
        ArchiveCreateRequest request = ArchiveCreateRequest.builder()
            .title("测试档案")
            .categoryId(1L)
            .build();
        
        Archive savedArchive = Archive.builder()
            .id(1L)
            .title("测试档案")
            .archiveNo("DA-2025-001")
            .build();
        
        when(archiveRepository.save(any(Archive.class))).thenReturn(savedArchive);
        
        // When
        ArchiveResponse response = archiveService.createArchive(request);
        
        // Then
        assertThat(response.getId()).isEqualTo(1L);
        assertThat(response.getTitle()).isEqualTo("测试档案");
        verify(archiveRepository).save(any(Archive.class));
    }
}
```

### 12.2 集成测试
```java
@SpringBootTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@TestPropertySource(locations = "classpath:application-test.properties")
class ArchiveControllerIntegrationTest {
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @Autowired
    private ArchiveRepository archiveRepository;
    
    @Test
    @WithMockUser(roles = "ARCHIVE_MANAGER")
    void createArchive_Integration_Success() {
        // Given
        ArchiveCreateRequest request = ArchiveCreateRequest.builder()
            .title("集成测试档案")
            .categoryId(1L)
            .build();
        
        // When
        ResponseEntity<ApiResponse> response = restTemplate.postForEntity(
            "/api/v1/archives", request, ApiResponse.class);
        
        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody().isSuccess()).isTrue();
        
        // 验证数据库
        List<Archive> archives = archiveRepository.findAll();
        assertThat(archives).hasSize(1);
        assertThat(archives.get(0).getTitle()).isEqualTo("集成测试档案");
    }
}
```

## 13. 性能优化

### 13.1 数据库优化
```java
// 使用批量操作
@Service
public class ArchiveServiceImpl implements ArchiveService {
    
    @Transactional
    public void batchCreateArchives(List<ArchiveCreateRequest> requests) {
        List<Archive> archives = requests.stream()
            .map(this::buildArchiveFromRequest)
            .collect(Collectors.toList());
        
        // 批量保存，减少数据库交互
        archiveRepository.saveAll(archives);
    }
    
    // 使用分页查询避免内存溢出
    public void processAllArchives() {
        int pageSize = 100;
        int pageNumber = 0;
        Page<Archive> page;
        
        do {
            Pageable pageable = PageRequest.of(pageNumber, pageSize);
            page = archiveRepository.findAll(pageable);
            
            // 处理当前页数据
            processArchivePage(page.getContent());
            
            pageNumber++;
        } while (page.hasNext());
    }
}
```

### 13.2 缓存优化
```java
@Service
public class ArchiveServiceImpl implements ArchiveService {
    
    // 缓存热点数据
    @Cacheable(value = "hot-archives", key = "'top-10'")
    public List<ArchiveResponse> getTopArchives() {
        return archiveRepository.findTop10ByOrderByViewCountDesc()
            .stream()
            .map(ArchiveResponse::from)
            .collect(Collectors.toList());
    }
    
    // 使用本地缓存减少Redis访问
    @Cacheable(value = "archive-categories", key = "'all'")
    public List<CategoryResponse> getAllCategories() {
        return categoryRepository.findAll()
            .stream()
            .map(CategoryResponse::from)
            .collect(Collectors.toList());
    }
}
```

## 14. 监控和健康检查

### 14.1 健康检查端点
```java
@Component
public class CustomHealthIndicator implements HealthIndicator {
    
    private final ArchiveRepository archiveRepository;
    private final RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public Health health() {
        try {
            // 检查数据库连接
            archiveRepository.count();
            
            // 检查Redis连接
            redisTemplate.opsForValue().get("health-check");
            
            return Health.up()
                .withDetail("database", "UP")
                .withDetail("redis", "UP")
                .build();
        } catch (Exception e) {
            return Health.down()
                .withDetail("error", e.getMessage())
                .build();
        }
    }
}
```

### 14.2 指标监控
```java
@RestController
@RequestMapping("/api/v1/metrics")
public class MetricsController {
    
    private final MeterRegistry meterRegistry;
    
    @GetMapping("/archives/count")
    public ResponseEntity<Long> getArchiveCount() {
        Counter counter = Counter.builder("archives.created")
            .description("档案创建数量")
            .register(meterRegistry);
        
        return ResponseEntity.ok(counter.count());
    }
}
```

## 15. 部署配置

### 15.1 应用配置文件
```yaml
# application.yml
spring:
  application:
    name: archive-management-system
  
  datasource:
    url: jdbc:mysql://localhost:3306/archive_db?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
    username: ${DB_USERNAME:archive_user}
    password: ${DB_PASSWORD:archive_pass}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  
  jpa:
    hibernate:
      ddl-auto: validate
    show-sql: false
    properties:
      hibernate:
        dialect: org.hibernate.dialect.MySQL8Dialect
        format_sql: true
  
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    password: ${REDIS_PASSWORD:}
    database: 0
    timeout: 5000ms
    lettuce:
      pool:
        max-active: 20
        max-idle: 10
        min-idle: 5
  
  rabbitmq:
    host: ${RABBITMQ_HOST:localhost}
    port: ${RABBITMQ_PORT:5672}
    username: ${RABBITMQ_USERNAME:guest}
    password: ${RABBITMQ_PASSWORD:guest}
    virtual-host: /

# MinIO配置
minio:
  endpoint: ${MINIO_ENDPOINT:http://localhost:9000}
  access-key: ${MINIO_ACCESS_KEY:minioadmin}
  secret-key: ${MINIO_SECRET_KEY:minioadmin}
  bucket-name: ${MINIO_BUCKET:archive-files}

# JWT配置
jwt:
  secret: ${JWT_SECRET:mySecretKey}
  expiration: 86400000 # 24小时

# 文件上传配置
file:
  upload:
    max-size: 100MB
    allowed-types: pdf,doc,docx,xls,xlsx,jpg,jpeg,png,gif
```

### 15.2 Dockerfile
```dockerfile
FROM openjdk:17-jre-slim

WORKDIR /app

COPY target/archive-management-system-*.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 15.3 Docker Compose
```yaml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8080:8080"
    environment:
      - DB_HOST=mysql
      - REDIS_HOST=redis
      - RABBITMQ_HOST=rabbitmq
      - MINIO_ENDPOINT=http://minio:9000
    depends_on:
      - mysql
      - redis
      - rabbitmq
      - minio
  
  mysql:
    image: mysql:8.0
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: archive_db
      MYSQL_USER: archive_user
      MYSQL_PASSWORD: archive_pass
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
  
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  rabbitmq:
    image: rabbitmq:3-management
    ports:
      - "5672:5672"
      - "15672:15672"
    environment:
      RABBITMQ_DEFAULT_USER: admin
      RABBITMQ_DEFAULT_PASS: admin
  
  minio:
    image: minio/minio
    ports:
      - "9000:9000"
      - "9001:9001"
    environment:
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
    command: server /data --console-address ":9001"
    volumes:
      - minio_data:/data

volumes:
  mysql_data:
  minio_data:
```

## 16. 最佳实践总结

### 16.1 代码质量
- 遵循SOLID原则
- 使用设计模式（策略、工厂、观察者等）
- 保持方法简洁，单一职责
- 编写有意义的测试用例
- 定期进行代码重构

### 16.2 性能优化
- 合理使用缓存策略
- 优化数据库查询
- 使用异步处理提高响应速度
- 实施分页和限流机制
- 监控关键性能指标

### 16.3 安全防护
- 实施多层安全防护
- 定期更新依赖版本
- 敏感信息加密存储
- 完善的审计日志
- 输入验证和输出编码

### 16.4 运维监控
- 完善的健康检查机制
- 详细的日志记录
- 关键指标监控
- 自动化部署流程
- 灾备和恢复方案

---

**文档版本**: v1.0  
**最后更新**: 2025-01-22  
**维护人员**: 后端开发团队