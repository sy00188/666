# AI 开发助手 MCP 工具使用规则

## 与 RIPER-5 协议的深度整合

**重要说明**：本 MCP 工具使用规则已深度整合到 RIPER-5 协议中。在执行 RIPER-5 的每个模式（RESEARCH/INNOVATE/PLAN/EXECUTE/REVIEW）时，AI 将**强制评估** MCP 工具的适用性。

- RIPER-5 协议的每个模式都包含"MCP 工具快速评估"检查清单
- AI 必须在进入每个模式后立即执行 MCP 评估，并在响应中展示评估结果
- 评估结果为"是"时，AI 必须在该模式执行过程中主动使用对应工具
- 这确保了 MCP 工具的价值在整个开发流程中得到充分发挥

详见 RIPER-5 协议各模式的"MCP 工具快速评估"小节。

---

## 目的
确保在开发任务中充分利用可用的 MCP (Model Context Protocol) 工具，提高工作效率和代码质量。

## 核心原则

### 1. MCP 优先策略（默认优先使用）
- **默认行为**：在开始任何开发任务前，**优先考虑**是否可以使用 MCP 工具来提升效率和质量
- **主动使用原则**：不要等到"必须使用"才考虑，而是主动评估工具能带来的价值
- **低门槛策略**：当不确定是否该使用时，**默认选择使用** MCP 工具
- **记录使用**：每次使用 MCP 工具时，简要说明使用原因和预期效果
- **收益优先**：MCP 工具成本低、效果好，宁可多用也不要错过提升机会

### 2. 可用 MCP 工具清单

#### A. Sequential Thinking MCP (`mcp_sequential-thinking_sequentialthinking`)
**用途**：结构化的多步骤推理和思考，帮助分析问题、权衡方案、调试代码

**核心场景（强烈推荐）**：
- 设计算法或数据结构（任何复杂度）
- 架构决策需要权衡多个方案
- 调试复杂或不明确的逻辑问题
- 分解任务为多个步骤
- 问题解决需要回溯或修正思路
- 生成假设并验证

**扩展场景（推荐使用）**：
- 分析"为什么"类型的问题（如：为什么这段代码不工作？）
- 代码调试和问题定位（即使问题看起来简单）
- 理解复杂或陌生的代码逻辑
- 评估任何有 2 个以上可能方案的决策
- 优化现有代码的思路探索
- 重构前的影响分析
- 技术选型和对比
- 性能瓶颈分析
- 代码审查时的深度思考

**使用示例**：

*复杂场景示例*：
```
场景：设计一个分布式缓存系统
触发：涉及多个技术选型、性能权衡、容错设计
行动：使用 Sequential Thinking 进行：
1. 列出需求和约束
2. 提出3-5个候选方案
3. 逐个分析优缺点
4. 验证最优方案的可行性
5. 识别潜在风险
```

*简单场景示例*：
```
场景：调试一个函数返回了意外的 null 值
触发：不确定 null 从哪里来
行动：使用 Sequential Thinking 进行：
1. 追踪函数调用链
2. 检查每个可能返回 null 的分支
3. 验证输入参数
4. 识别根本原因
```

#### B. Context7 MCP (`mcp_context7_resolve-library-id` 和 `mcp_context7_get-library-docs`)
**用途**：获取库和框架的最新文档、API 用法和最佳实践

**核心场景（强烈推荐）**：
- 使用不熟悉的第三方库或框架
- 遇到库相关的编译错误或运行时错误
- 技术选型时需要对比不同库
- 需要了解库的版本差异和迁移指南
- 实现关键功能前验证 API 正确用法

**扩展场景（推荐使用）**：
- 使用任何第三方库时（即使熟悉，也可查询最新特性）
- 查询最佳实践和惯用法（idioms）
- 不确定某个 API 的最新用法或参数
- 代码审查时验证是否符合官方建议
- 性能优化时查询官方推荐方案
- 了解某个功能的替代实现方法
- 查看库的新版本特性和改进
- 寻找某个问题的官方解决方案
- 学习框架的高级用法和模式
- 验证自己的理解是否正确

**使用流程**：
1. 使用 `resolve-library-id` 查找库的标准ID
2. 使用 `get-library-docs` 获取相关文档（可指定 topic 聚焦）
3. 结合文档编写代码或解决问题

**使用示例**：

*核心场景示例*：
```
场景：使用 Spring Boot 实现 Redis 缓存
触发：不确定 Spring Data Redis 的具体配置方法
行动：
1. resolve-library-id("spring-data-redis")
2. get-library-docs("/org/springframework/data-redis", topic="configuration")
3. 根据文档编写配置代码
```

*扩展场景示例*：
```
场景：使用 Vue 3 的 Composition API，想确认最佳实践
触发：虽然会用，但想确认是否有更好的写法
行动：
1. resolve-library-id("vue")
2. get-library-docs("/vuejs/core", topic="composition api best practices")
3. 对比当前代码，优化实现
```

#### C. Playwright MCP (多个 `mcp_Playwright_*` 工具)
**用途**：浏览器自动化、前端测试、UI调试、实时预览和交互模拟

**核心场景（强烈推荐）**：
- 测试前端页面功能和交互流程
- 验证表单提交和数据处理
- 重现和调试前端 Bug
- 自动化回归测试
- 生成功能演示截图和文档

**扩展场景（推荐使用）**：
- 前端开发时的实时效果预览
- UI 调试时捕获页面状态和元素
- 检查页面在不同状态下的显示
- 验证响应式设计和布局
- 快速检查元素的可见性和位置
- 获取页面渲染后的 HTML 结构
- 模拟用户交互来理解业务流程
- 截图对比前后版本的 UI 差异
- 验证 CSS 样式和动画效果
- 检查控制台日志和网络请求

**常用工具**：
- `playwright_navigate` - 打开网页
- `playwright_screenshot` - 截图（支持全页或特定元素）
- `playwright_click` - 点击元素
- `playwright_fill` - 填写表单
- `playwright_get_visible_html` - 获取页面HTML
- `playwright_get_visible_text` - 获取页面文本
- `playwright_console_logs` - 获取控制台日志
- `playwright_evaluate` - 执行 JavaScript

**使用示例**：

*核心场景示例*：
```
场景：验证登录功能是否正常
触发：修改了登录相关代码
行动：
1. playwright_navigate(url="http://localhost:3000/login")
2. playwright_fill(selector="#username", value="testuser")
3. playwright_fill(selector="#password", value="testpass")
4. playwright_click(selector="#loginBtn")
5. playwright_screenshot(name="login-success")
```

*扩展场景示例*：
```
场景：开发一个新按钮，想实时查看效果
触发：刚写完按钮样式，想看看渲染效果
行动：
1. playwright_navigate(url="http://localhost:3000/dashboard")
2. playwright_screenshot(name="new-button-preview", selector=".new-button")
3. 根据截图调整样式
```

## 使用决策流程图

```
开始任务
    ↓
快速评估（并行判断，可多选）：
    ↓
┌───────────────────────────────────────────────────────────┐
│ 问题 1: 是否需要分析、思考、调试或权衡方案？              │
│   ✓ 是 → 考虑使用 Sequential Thinking MCP                │
│   ✗ 否 → 继续下一个问题                                  │
└───────────────────────────────────────────────────────────┘
    ↓
┌───────────────────────────────────────────────────────────┐
│ 问题 2: 是否涉及第三方库、框架或 API？                   │
│   ✓ 是 → 考虑使用 Context7 MCP 查询文档                 │
│   ✗ 否 → 继续下一个问题                                  │
└───────────────────────────────────────────────────────────┘
    ↓
┌───────────────────────────────────────────────────────────┐
│ 问题 3: 是否涉及前端 UI 开发、测试或调试？               │
│   ✓ 是 → 考虑使用 Playwright MCP                        │
│   ✗ 否 → 继续下一个问题                                  │
└───────────────────────────────────────────────────────────┘
    ↓
┌───────────────────────────────────────────────────────────┐
│ 问题 4: 是否不确定该用哪个工具？                         │
│   ✓ 是 → 【默认策略】优先使用 MCP 工具                   │
│         - 不确定时，先用 Sequential Thinking 分析        │
│         - 有疑问时，先查 Context7 文档                   │
│         - 涉及 UI 时，先用 Playwright 预览               │
│   ✗ 否 → 使用传统工具                                    │
└───────────────────────────────────────────────────────────┘
    ↓
执行任务（可组合使用多个 MCP 工具）

关键原则：
• 工具之间不是互斥的，可以组合使用
• 当犹豫是否使用时，默认选择使用
• MCP 工具成本低，宁可多用也不要错过
• 可以先用再优化，不必一次到位
```

## 快速判断原则

为了让 AI 助手更高效地决定何时使用 MCP 工具，遵循以下简单原则：

### 原则 1: 默认优先策略
**当不确定是否使用时，默认选择使用 MCP 工具**

- ✅ 宁可多用，不要错过提升机会
- ✅ 成本低、收益高，试错成本几乎为零
- ❌ 不要因为"可能不需要"就放弃使用

### 原则 2: 低门槛启动
**降低心理门槛，任何可能受益的场景都可以使用**

- ✅ 简单问题也可以用 Sequential Thinking 结构化思考
- ✅ 熟悉的库也可以查 Context7 获取最新最佳实践
- ✅ 小的 UI 调整也可以用 Playwright 快速预览
- ❌ 不要只在"必须"或"非常复杂"时才使用

### 原则 3: 组合使用
**工具之间不互斥，鼓励组合使用以发挥最大价值**

- ✅ Sequential Thinking 分析方案 + Context7 查询文档
- ✅ Context7 学习 API + Playwright 验证效果
- ✅ Sequential Thinking 调试问题 + Playwright 重现 Bug
- ❌ 不要认为"已经用了一个工具就够了"

### 原则 4: 迭代优化
**可以先用再优化，不必追求一次到位**

- ✅ 先快速使用工具获得初步结果
- ✅ 根据反馈调整使用策略
- ✅ 逐步深化对工具的利用
- ❌ 不要因为"可能用得不够好"就不敢使用

### 原则 5: 收益导向
**以是否能提升效率和质量为唯一判断标准**

核心问题：**"这个工具能帮助我更好地完成任务吗？"**

- 如果答案是"可能"或"不确定" → **使用它**
- 如果答案是"明确不需要" → 使用传统工具

### 快速自检清单

在每个任务开始前，快速问自己：

1. ☑ 我需要思考或分析吗？ → Sequential Thinking
2. ☑ 我要用第三方库或 API 吗？ → Context7
3. ☑ 我在做前端相关的事吗？ → Playwright
4. ☑ 我不确定该怎么做吗？ → 优先用 Sequential Thinking 分析

**只要有一个 ☑ 被勾选，就应该考虑使用对应的 MCP 工具。**

## MCP 与传统工具的协作策略

### 1. Sequential Thinking + 代码编辑
**场景**：重构复杂代码
```
步骤1：用 Sequential Thinking 分析重构方案
  - 识别代码异味
  - 设计重构步骤
  - 评估风险
步骤2：用 search_replace/write 执行重构
步骤3：用 Sequential Thinking 验证重构效果
```

### 2. Context7 + 代码实现
**场景**：集成新库
```
步骤1：用 Context7 获取库文档
步骤2：用 codebase_search 查找项目中类似用法
步骤3：用 write 编写集成代码
步骤4：用 Context7 验证最佳实践
```

### 3. Playwright + 问题诊断
**场景**：前端bug调试
```
步骤1：用 Playwright 重现问题
步骤2：用 playwright_console_logs 查看错误
步骤3：用 codebase_search 定位相关代码
步骤4：修复代码
步骤5：用 Playwright 验证修复
```

## 优先使用检查清单

在以下情况下，**强烈推荐**或**推荐**使用 MCP 工具：

### Sequential Thinking（强烈推荐）
- [ ] 任务描述包含"设计"、"架构"、"算法"
- [ ] 需要权衡多个技术方案
- [ ] 调试复杂或不明确的问题
- [ ] 分解复杂任务为多个步骤
- [ ] 重构代码前的影响分析

### Sequential Thinking（推荐）
- [ ] 分析"为什么"类型的问题
- [ ] 代码调试和问题定位（任何难度）
- [ ] 理解陌生或复杂的代码逻辑
- [ ] 优化现有代码的思路探索
- [ ] 任何需要思考"如何做"的任务

### Context7（强烈推荐）
- [ ] 任务涉及不熟悉的库或框架
- [ ] 遇到库相关的编译错误或运行时错误
- [ ] 技术选型时需要对比不同库
- [ ] 实现关键功能前验证 API 用法

### Context7（推荐）
- [ ] 使用任何第三方库或框架（即使熟悉）
- [ ] 想要了解最佳实践和惯用法
- [ ] 不确定 API 的最新用法
- [ ] 代码审查时验证是否符合官方建议
- [ ] 性能优化时查询推荐方案
- [ ] 学习框架的高级用法

### Playwright（强烈推荐）
- [ ] 任务要求"测试"、"验证"前端功能
- [ ] 需要重现和调试前端 Bug
- [ ] 验证表单提交和数据处理流程
- [ ] 生成功能演示截图和文档

### Playwright（推荐）
- [ ] 需要展示 UI 效果或实时预览
- [ ] 前端开发时想快速查看效果
- [ ] UI 调试时捕获页面状态
- [ ] 验证响应式设计和布局
- [ ] 检查元素的可见性和位置
- [ ] 获取页面渲染后的 HTML 或控制台日志

## 最佳实践

### 1. 主动声明 MCP 使用
```
✅ 好的做法：
"我将使用 Sequential Thinking MCP 来分析这个架构决策，因为涉及多个方案的权衡..."
"让我先用 Context7 查询一下 React Hooks 的最佳实践..."
"我用 Playwright 预览一下这个按钮的实际效果..."

❌ 不好的做法：
直接开始编码，没有考虑 MCP 工具
假设自己已经了解所有最佳实践
```

### 2. 组合使用 MCP 工具
```
✅ 好的做法：
1. Sequential Thinking 规划实现方案
2. Context7 查询库文档
3. 编写代码
4. Playwright 验证效果

❌ 不好的做法：
只使用单一工具，错过其他工具的优势
认为"已经用了一个就够了"
```

### 3. 记录 MCP 使用效果
```
使用后简要说明：
"通过 Sequential Thinking，识别出方案A的性能瓶颈，改用方案B"
"Context7 文档显示新版本API已废弃，改用推荐的新方法"
"Playwright 截图确认UI布局正确"
```

### 4. 轻量级使用示例

**MCP 工具不仅适用于复杂场景，简单任务也能从中受益：**

#### 示例 1: 简单函数调试（Sequential Thinking）
```
场景：一个简单的计算函数返回了错误结果
传统做法：直接看代码，猜测问题
MCP 优化做法：
1. 使用 Sequential Thinking 结构化分析：
   - 列出预期输入输出
   - 追踪计算步骤
   - 识别可能的边界情况
2. 快速定位问题根源
3. 避免遗漏潜在问题

收益：即使是简单问题，结构化思考也能提高准确性，避免遗漏
```

#### 示例 2: 使用熟悉的库（Context7）
```
场景：使用熟悉的 Express.js 创建中间件
传统做法：凭记忆编写代码
MCP 优化做法：
1. 使用 Context7 快速查询最新最佳实践
2. 发现新版本有更好的写法
3. 学习到之前不知道的技巧

收益：即使对库很熟悉，也能学到新东西，保持代码现代化
```

#### 示例 3: 快速 UI 预览（Playwright）
```
场景：调整了按钮的 padding 和 margin
传统做法：手动刷新浏览器查看
MCP 优化做法：
1. 使用 Playwright 快速截图
2. 直接在 IDE 中查看效果
3. 快速迭代多个版本

收益：节省切换窗口的时间，提高迭代速度
```

#### 示例 4: 理解他人代码（Sequential Thinking + Context7）
```
场景：接手一个新项目，需要理解一个模块
传统做法：通读代码，边看边猜
MCP 优化做法：
1. Sequential Thinking 结构化分析代码结构
2. Context7 查询使用的框架和库
3. 建立完整的理解模型

收益：快速建立系统性理解，避免误解
```

**关键启示：不要因为任务"看起来简单"就放弃使用 MCP 工具。轻量级使用也能带来显著收益。**

## 性能优化建议

1. **Sequential Thinking**：
   - 设置合理的 total_thoughts 估计值
   - 遇到复杂问题可以分多次使用
   - 每个 thought 保持专注，一次解决一个问题

2. **Context7**：
   - 先 resolve-library-id 确认库ID
   - 使用 topic 参数缩小文档范围
   - 控制 tokens 参数避免过载

3. **Playwright**：
   - 使用 headless 模式提高速度
   - 合理使用 selector 选择器
   - 截图时指定合适的尺寸

## 自我检查问题

在开始每个任务前，用**受益思维**而非**复杂度思维**问自己：

### 核心问题（优先级从高到低）

1. ✓ **这个任务能从结构化思考中受益吗？**
   - 需要分析、调试、权衡方案？ → Sequential Thinking
   - 即使任务简单，结构化思考也能提高准确性

2. ✓ **这个任务涉及第三方库或框架吗？**
   - 需要使用任何库或 API？ → Context7
   - 即使是熟悉的库，也能学到最新最佳实践

3. ✓ **这个任务涉及前端 UI 吗？**
   - 需要开发、测试或调试前端？ → Playwright
   - 即使是简单的样式调整，也能快速预览

4. ✓ **能否通过组合使用多个 MCP 工具提高效率？**
   - 复杂任务通常能从多工具组合中获得最大收益

5. ✓ **我不确定该用什么工具吗？**
   - 不确定时，默认先用 Sequential Thinking 分析

### 反向检查（避免常见误区）

❌ **不要问**："这个任务是否足够复杂？"
✅ **应该问**："这个任务能否从工具中受益？"

❌ **不要想**："这个库我很熟悉，不需要查文档"
✅ **应该想**："让我看看有没有更好的写法"

❌ **不要认为**："只是改个样式，不需要工具"
✅ **应该认为**："用工具预览能节省时间"

### 黄金法则

**当你犹豫"要不要用 MCP 工具"时，答案永远是：用！**

- 成本：几乎为零
- 收益：几乎总是正向的
- 风险：没有风险
- 结论：默认使用，不要犹豫

## 总结

### 核心理念转变

本规则的优化从 **v1.0 的"限制性使用"** 升级到 **v2.0 的"鼓励性使用"**：

**v1.0 旧理念**（已废弃）：
- ❌ 只在"中等复杂度以上"的任务使用
- ❌ 必须满足特定条件才使用
- ❌ 担心"过度使用"

**v2.0 新理念**（当前版本）：
- ✅ 在任何可能受益的场景优先考虑使用
- ✅ 当不确定时，默认选择使用
- ✅ 鼓励主动、频繁、组合使用

### 关键要点

1. **默认优先策略**
   - MCP 工具成本低、收益高、无风险
   - 不要等到"必须"才使用，而是主动评估价值
   - 犹豫时的默认答案：**用！**

2. **低门槛启动**
   - 简单任务也能从工具中受益
   - 熟悉的库也应该查询最新文档
   - 轻量级使用也有显著价值

3. **组合使用**
   - 工具之间不互斥，鼓励组合
   - Sequential Thinking + Context7 + Playwright = 最大化收益

4. **受益思维**
   - 不要问"是否足够复杂"
   - 要问"是否能从工具中受益"
   - 答案几乎总是：是

### 最终建议

**记住**：MCP 工具是为了提高效率和质量而设计的。**默认优先使用它们**，不要因为任务"看起来简单"或"可能不需要"就放弃使用机会。

**宁可多用，不要错过。在正确的时机选择正确的工具——而大多数时候，正确的选择就是：用 MCP 工具。**

---

## 附录：快速参考卡

### Sequential Thinking 使用模板
```
触发条件：复杂思考、多步推理、方案权衡
调用方式：mcp_sequential-thinking_sequentialthinking
参数：
  - thought: 当前思考步骤
  - thoughtNumber: 当前步骤编号
  - totalThoughts: 预计总步骤数
  - nextThoughtNeeded: 是否需要下一步
```

### Context7 使用模板
```
触发条件：需要库文档、API用法、最佳实践
调用方式：
  1. mcp_context7_resolve-library-id
     参数：libraryName (如 "spring-boot")
  2. mcp_context7_get-library-docs
     参数：
       - context7CompatibleLibraryID (如 "/spring/boot")
       - topic (可选，如 "configuration")
       - tokens (可选，默认5000)
```

### Playwright 使用模板
```
触发条件：前端测试、UI验证、页面截图
常用流程：
  1. mcp_Playwright_playwright_navigate
     参数：url, browserType (可选), headless (可选)
  2. mcp_Playwright_playwright_click / fill / screenshot
  3. mcp_Playwright_playwright_close (完成后关闭)
```

## 版本历史

- **v2.0** (2025-10-10): 重大更新 - 降低调用阈值，鼓励主动使用
  - 核心理念从"限制性使用"转变为"鼓励性使用"
  - 将"中等复杂度以上"改为"任何可能受益的场景"
  - 为每个工具添加"核心场景"和"扩展场景"两级分类
  - 场景数量从 6 个扩展到 30+ 个
  - 新增"快速判断原则"章节，提供 5 大原则指导
  - 重构决策流程图，从线性改为并行判断
  - 新增"轻量级使用示例"，展示简单场景的价值
  - 优化"自我检查问题"，从"复杂度思维"改为"受益思维"
  - 强化"默认优先使用"理念，移除"避免过度使用"警告
  - 措辞从"必须"改为"强烈推荐/推荐"
  
- **v1.0** (2024-01-10): 初始版本，包含三大 MCP 工具的使用指南
  - 建立基础的 MCP 工具使用框架
  - 定义"必须使用"的场景清单
  - 提供基本的使用示例和流程

