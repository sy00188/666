# 档案管理系统 - 项目完善计划与行动指南

> **生成时间**: 2025年10月10日  
> **项目状态**: 核心功能已完成，需要优化提升  
> **完成度评估**: 85%  
> **建议执行周期**: 3-6个月

---

## 📊 项目现状全面评估

### ✅ 已完成的核心功能

#### 1. 后端架构 (完成度: 90%)
- **技术栈**: Spring Boot 3.2.x + Spring Security 6.x + MyBatis Plus
- **控制器层**: 21个Controller，覆盖所有核心业务
- **服务层**: 35个Service实现，业务逻辑完整
- **Java文件**: 324个源文件，代码量充足

**核心模块清单**:
- ✅ 用户认证与授权 (AuthController, AuthService)
- ✅ 档案管理 (ArchiveController, ArchiveService)
- ✅ 借阅管理 (BorrowController, BorrowService)
- ✅ 权限管理 (PermissionController, RoleController)
- ✅ 系统配置 (SystemController, SystemConfigController)
- ✅ 统计分析 (StatisticsController, StatisticsService)
- ✅ 审计日志 (AuditLogController, AuditLogService)
- ✅ 通知服务 (NotificationController, NotificationService)
- ✅ 工作流引擎 (WorkflowController, WorkflowService)
- ✅ 高级搜索 (AdvancedSearchController, AdvancedSearchService)
- ✅ 批量操作 (BatchOperationController)
- ✅ 文件管理 (ArchiveFileController, FileStorageService)
- ✅ 导出功能 (ExportController, MultiFormatExportService)
- ✅ 性能监控 (PerformanceMonitoringController)
- ✅ 分类管理 (CategoryController, CategoryService)

#### 2. 前端架构 (完成度: 85%)
- **技术栈**: Vue 3 + TypeScript + Element Plus + Vite
- **页面数量**: 30+个页面组件
- **路由配置**: 完整的路由守卫和权限控制

**已实现页面**:
- ✅ 认证模块: 登录、注册
- ✅ 仪表板: 数据概览
- ✅ 档案管理: 列表、详情、新增/编辑、分类、高级搜索
- ✅ 借阅管理: 借阅记录、申请、归还、逾期管理
- ✅ 用户管理: 用户列表
- ✅ 统计分析: 数据概览、档案统计、借阅统计、用户统计、报表管理、用户行为分析、系统监控
- ✅ 通知中心: 消息通知
- ✅ 系统管理: 用户管理、角色管理、权限管理、操作日志、系统设置、个性化设置
- ✅ 错误页面: 403、404

#### 3. 数据库设计 (完成度: 95%)
- **数据库**: MySQL 8.0+
- **表结构**: 完整的数据库设计文档
- **SQL脚本**: 多个初始化和优化脚本
  - 01_database_init.sql - 数据库初始化
  - 02_constraints.sql - 约束定义
  - 03_triggers.sql - 触发器
  - 04_init_data.sql - 初始数据
  - 05_maintenance.sql - 维护脚本
  - 06_additional_tables.sql - 扩展表
  - 07_wechat_login.sql - 微信登录
  - 08_backup_table.sql - 备份表
  - 09_notification_template_table.sql - 通知模板
  - 10_export_task.sql - 导出任务

#### 4. 基础设施 (完成度: 80%)
- ✅ Docker容器化部署
- ✅ Docker Compose编排
- ✅ Nginx反向代理配置
- ✅ 性能监控 (Prometheus + Grafana)
- ✅ 日志管理
- ✅ 备份机制

---

## 🎯 需要完善的功能模块

### 高优先级 (1-2个月完成)

#### 1. 实时通知系统增强 ⭐⭐⭐⭐⭐
**当前状态**: 基础通知功能已实现，但缺少实时推送  
**业务价值**: 提升用户体验和工作效率  
**技术难度**: ⭐⭐⭐

**需要实现的功能**:
- [ ] WebSocket实时消息推送
- [ ] 消息中心UI界面优化
- [ ] 未读消息数量提示
- [ ] 消息分类和筛选
- [ ] 消息批量操作 (标记已读、删除)
- [ ] 邮件通知模板系统
- [ ] 短信通知集成 (可选)
- [ ] 消息推送策略配置

**技术实现方案**:
```java
// WebSocket配置
@Configuration
@EnableWebSocket
public class WebSocketConfig implements WebSocketConfigurer {
    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        registry.addHandler(notificationHandler(), "/ws/notifications")
                .setAllowedOrigins("*")
                .withSockJS();
    }
}

// 消息推送服务
@Service
public class RealtimeNotificationService {
    private final SimpMessagingTemplate messagingTemplate;
    
    public void pushToUser(Long userId, Notification notification) {
        messagingTemplate.convertAndSendToUser(
            userId.toString(), 
            "/queue/notifications", 
            notification
        );
    }
}
```

**前端实现**:
```typescript
// WebSocket连接管理
export class NotificationWebSocket {
  private socket: WebSocket | null = null;
  
  connect(userId: string) {
    this.socket = new WebSocket(`ws://localhost:8080/ws/notifications`);
    this.socket.onmessage = (event) => {
      const notification = JSON.parse(event.data);
      this.handleNotification(notification);
    };
  }
  
  private handleNotification(notification: any) {
    // 显示通知提示
    ElNotification({
      title: notification.title,
      message: notification.content,
      type: notification.type
    });
    
    // 更新未读消息数
    notificationStore.incrementUnread();
  }
}
```

**预期成果**:
- 实时消息推送延迟 < 500ms
- 支持1000+并发WebSocket连接
- 消息送达率 > 99%

#### 2. 移动端响应式适配 ⭐⭐⭐⭐⭐
**当前状态**: 主要面向桌面端设计  
**业务价值**: 满足移动办公需求，扩大用户群体  
**技术难度**: ⭐⭐⭐

**需要实现的功能**:
- [ ] 响应式布局优化 (适配手机、平板)
- [ ] 移动端导航菜单优化
- [ ] 触摸手势支持
- [ ] 移动端表单优化
- [ ] 移动端表格优化 (滑动、折叠)
- [ ] 图片/文件上传优化
- [ ] 离线数据缓存 (可选)
- [ ] PWA支持 (可选)

**技术实现方案**:
```vue
<!-- 响应式布局示例 -->
<template>
  <div class="responsive-container">
    <!-- 桌面端显示 -->
    <el-table v-if="!isMobile" :data="tableData">
      <!-- 完整表格列 -->
    </el-table>
    
    <!-- 移动端显示 -->
    <div v-else class="mobile-list">
      <el-card v-for="item in tableData" :key="item.id" class="mobile-card">
        <!-- 卡片式显示 -->
      </el-card>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted } from 'vue';

const isMobile = ref(false);

const checkDevice = () => {
  isMobile.value = window.innerWidth < 768;
};

onMounted(() => {
  checkDevice();
  window.addEventListener('resize', checkDevice);
});

onUnmounted(() => {
  window.removeEventListener('resize', checkDevice);
});
</script>

<style scoped>
.mobile-card {
  margin-bottom: 10px;
}

@media (max-width: 768px) {
  .responsive-container {
    padding: 10px;
  }
}
</style>
```

**CSS媒体查询策略**:
```scss
// 响应式断点
$breakpoints: (
  'mobile': 576px,
  'tablet': 768px,
  'desktop': 1024px,
  'wide': 1440px
);

// 移动端优化
@media (max-width: 768px) {
  .sidebar {
    position: fixed;
    transform: translateX(-100%);
    transition: transform 0.3s;
    
    &.open {
      transform: translateX(0);
    }
  }
  
  .main-content {
    margin-left: 0;
  }
  
  .table-container {
    overflow-x: auto;
  }
}
```

**预期成果**:
- 支持屏幕尺寸: 320px - 1920px
- 移动端页面加载时间 < 3秒
- 触摸操作流畅度 > 90%

#### 3. 高级报表系统 ⭐⭐⭐⭐
**当前状态**: 基础统计功能存在  
**业务价值**: 支持数据驱动决策  
**技术难度**: ⭐⭐⭐⭐

**需要实现的功能**:
- [ ] 可视化报表构建器
- [ ] 自定义报表模板
- [ ] 多维度数据分析
- [ ] 数据导出 (Excel, PDF, CSV)
- [ ] 定时报表生成
- [ ] 报表订阅和推送
- [ ] 报表权限控制
- [ ] 交互式图表 (ECharts)

**技术实现方案**:
```java
// 报表生成服务
@Service
public class ReportGenerationService {
    
    public ReportResult generateReport(ReportConfig config) {
        // 1. 构建查询SQL
        String sql = buildQuerySQL(config);
        
        // 2. 执行查询
        List<Map<String, Object>> data = jdbcTemplate.queryForList(sql);
        
        // 3. 数据处理和聚合
        ReportData processed = processData(data, config);
        
        // 4. 生成图表配置
        ChartConfig chartConfig = generateChartConfig(processed, config);
        
        // 5. 保存报表
        return saveReport(processed, chartConfig, config);
    }
    
    public byte[] exportToExcel(Long reportId) {
        ReportData data = getReportData(reportId);
        return excelExporter.export(data);
    }
    
    public byte[] exportToPDF(Long reportId) {
        ReportData data = getReportData(reportId);
        return pdfExporter.export(data);
    }
}
```

**前端报表配置器**:
```vue
<template>
  <div class="report-builder">
    <!-- 数据源选择 -->
    <el-form-item label="数据源">
      <el-select v-model="config.dataSource">
        <el-option label="档案数据" value="archive" />
        <el-option label="借阅数据" value="borrow" />
        <el-option label="用户数据" value="user" />
      </el-select>
    </el-form-item>
    
    <!-- 维度选择 -->
    <el-form-item label="分析维度">
      <el-checkbox-group v-model="config.dimensions">
        <el-checkbox label="时间" />
        <el-checkbox label="分类" />
        <el-checkbox label="部门" />
      </el-checkbox-group>
    </el-form-item>
    
    <!-- 指标选择 -->
    <el-form-item label="分析指标">
      <el-checkbox-group v-model="config.metrics">
        <el-checkbox label="数量" />
        <el-checkbox label="占比" />
        <el-checkbox label="增长率" />
      </el-checkbox-group>
    </el-form-item>
    
    <!-- 图表类型 -->
    <el-form-item label="图表类型">
      <el-radio-group v-model="config.chartType">
        <el-radio label="line">折线图</el-radio>
        <el-radio label="bar">柱状图</el-radio>
        <el-radio label="pie">饼图</el-radio>
      </el-radio-group>
    </el-form-item>
    
    <!-- 预览和生成 -->
    <el-button type="primary" @click="generateReport">生成报表</el-button>
  </div>
</template>
```

**预期成果**:
- 支持10+种报表类型
- 报表生成时间 < 5秒
- 支持百万级数据分析

---

### 中优先级 (2-3个月完成)

#### 4. 文档在线预览增强 ⭐⭐⭐⭐
**当前状态**: 基础文件上传下载  
**业务价值**: 提高查阅效率  
**技术难度**: ⭐⭐⭐⭐

**需要实现的功能**:
- [ ] PDF在线预览
- [ ] Office文档预览 (Word, Excel, PPT)
- [ ] 图片预览和缩放
- [ ] 视频预览
- [ ] 文档水印
- [ ] 文档版本控制
- [ ] 文档对比功能
- [ ] 文档批注功能 (可选)

**技术方案选型**:

| 方案 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| **PDF.js** | 开源免费，功能完善 | 仅支持PDF | ⭐⭐⭐⭐⭐ |
| **Office Online** | 微软官方，支持全格式 | 需要Office 365授权 | ⭐⭐⭐ |
| **LibreOffice在线** | 开源，支持Office格式 | 性能一般，部署复杂 | ⭐⭐⭐ |
| **ONLYOFFICE** | 功能强大，UI美观 | 社区版有限制 | ⭐⭐⭐⭐ |
| **永中Office** | 国产方案，兼容性好 | 需要商业授权 | ⭐⭐⭐ |

**推荐方案**: PDF.js (PDF) + ONLYOFFICE社区版 (Office文档)

**技术实现**:
```java
// 文档预览服务
@Service
public class DocumentPreviewService {
    
    public PreviewUrl generatePreviewUrl(Long fileId) {
        ArchiveFile file = fileService.getById(fileId);
        String fileType = getFileType(file.getFileName());
        
        switch (fileType) {
            case "pdf":
                return generatePdfPreview(file);
            case "doc", "docx":
                return generateWordPreview(file);
            case "xls", "xlsx":
                return generateExcelPreview(file);
            case "ppt", "pptx":
                return generatePptPreview(file);
            default:
                throw new UnsupportedFileTypeException(fileType);
        }
    }
    
    private PreviewUrl generatePdfPreview(ArchiveFile file) {
        // 使用PDF.js
        return PreviewUrl.builder()
            .url("/pdfjs/web/viewer.html?file=" + file.getStoragePath())
            .type("pdf")
            .build();
    }
    
    private PreviewUrl generateWordPreview(ArchiveFile file) {
        // 转换为PDF或使用ONLYOFFICE
        String convertedPath = convertToPdf(file);
        return PreviewUrl.builder()
            .url(convertedPath)
            .type("office")
            .build();
    }
}
```

**前端预览组件**:
```vue
<template>
  <div class="document-preview">
    <!-- PDF预览 -->
    <iframe 
      v-if="fileType === 'pdf'" 
      :src="previewUrl" 
      class="preview-iframe"
    />
    
    <!-- Office文档预览 -->
    <div v-else-if="isOfficeFile" id="onlyoffice-container" />
    
    <!-- 图片预览 -->
    <el-image 
      v-else-if="isImage" 
      :src="previewUrl" 
      :preview-src-list="[previewUrl]"
      fit="contain"
    />
    
    <!-- 不支持预览 -->
    <div v-else class="no-preview">
      <el-icon><DocumentDelete /></el-icon>
      <p>该文件类型不支持在线预览</p>
      <el-button @click="download">下载文件</el-button>
    </div>
  </div>
</template>
```

**预期成果**:
- 支持文件格式: PDF, Word, Excel, PPT, 图片
- 预览加载时间 < 3秒
- 预览成功率 > 95%

#### 5. 全文检索优化 ⭐⭐⭐⭐
**当前状态**: 基础数据库搜索  
**业务价值**: 提高检索效率和准确性  
**技术难度**: ⭐⭐⭐⭐

**需要实现的功能**:
- [ ] Elasticsearch集成
- [ ] 中文分词 (IK Analyzer)
- [ ] 全文索引构建
- [ ] 高亮显示
- [ ] 模糊搜索
- [ ] 搜索建议
- [ ] 搜索历史
- [ ] 热门搜索

**技术实现**:
```java
// Elasticsearch配置
@Configuration
public class ElasticsearchConfig {
    @Bean
    public RestHighLevelClient client() {
        return new RestHighLevelClient(
            RestClient.builder(
                new HttpHost("localhost", 9200, "http")
            )
        );
    }
}

// 全文检索服务
@Service
public class FullTextSearchService {
    
    @Autowired
    private RestHighLevelClient client;
    
    public SearchResult search(String keyword, int page, int size) {
        SearchRequest request = new SearchRequest("archives");
        SearchSourceBuilder builder = new SearchSourceBuilder();
        
        // 多字段搜索
        builder.query(QueryBuilders.multiMatchQuery(keyword, 
            "title", "content", "keywords", "description")
            .analyzer("ik_smart")
        );
        
        // 高亮设置
        builder.highlighter(new HighlightBuilder()
            .field("title")
            .field("content")
            .preTags("<em class='highlight'>")
            .postTags("</em>")
        );
        
        // 分页
        builder.from(page * size).size(size);
        
        // 执行搜索
        SearchResponse response = client.search(request, RequestOptions.DEFAULT);
        
        return parseSearchResult(response);
    }
    
    public List<String> getSuggestions(String prefix) {
        // 搜索建议
        CompletionSuggestionBuilder suggestion = 
            SuggestBuilders.completionSuggestion("title.suggest")
                .prefix(prefix)
                .size(10);
        
        // 执行建议查询
        // ...
        
        return suggestions;
    }
}
```

**预期成果**:
- 搜索响应时间 < 200ms
- 支持千万级数据检索
- 搜索准确率 > 90%

#### 6. 系统集成能力 ⭐⭐⭐
**当前状态**: 独立系统  
**业务价值**: 与企业现有系统打通  
**技术难度**: ⭐⭐⭐

**需要实现的功能**:
- [ ] 单点登录 (SSO) - CAS/OAuth2
- [ ] API网关集成
- [ ] 企业微信集成
- [ ] 钉钉集成
- [ ] LDAP/AD域集成
- [ ] Webhook通知
- [ ] 开放API文档 (Swagger)
- [ ] API版本管理

**技术实现**:
```java
// OAuth2配置
@Configuration
@EnableAuthorizationServer
public class OAuth2Config extends AuthorizationServerConfigurerAdapter {
    
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
            .withClient("archive-client")
            .secret("{noop}secret")
            .authorizedGrantTypes("authorization_code", "refresh_token")
            .scopes("read", "write")
            .redirectUris("http://localhost:3000/callback");
    }
}

// 企业微信集成
@Service
public class WeChatWorkIntegrationService {
    
    public void sendMessage(Long userId, String message) {
        // 调用企业微信API发送消息
        WeChatWorkClient client = new WeChatWorkClient(corpId, corpSecret);
        client.sendTextMessage(userId, message);
    }
    
    public UserInfo syncUser(String wechatUserId) {
        // 同步企业微信用户信息
        WeChatUser wechatUser = client.getUserInfo(wechatUserId);
        return convertToSystemUser(wechatUser);
    }
}
```

**预期成果**:
- 支持3+种SSO方案
- 支持企业微信/钉钉消息推送
- API文档覆盖率100%

---

### 低优先级 (3-6个月完成)

#### 7. 智能化功能 ⭐⭐⭐
**当前状态**: 无  
**业务价值**: 提升自动化水平  
**技术难度**: ⭐⭐⭐⭐⭐

**需要实现的功能**:
- [ ] OCR文字识别
- [ ] 智能分类推荐
- [ ] 智能标签生成
- [ ] 智能查重
- [ ] 智能摘要生成
- [ ] 档案关联推荐

**技术方案**:
- **OCR服务**: 百度OCR / 腾讯OCR / Tesseract (开源)
- **NLP服务**: 百度AI / 阿里云NLP / 自建模型
- **推荐算法**: 协同过滤 / 内容推荐

#### 8. 高级安全功能 ⭐⭐⭐
**需要实现的功能**:
- [ ] 数据脱敏
- [ ] 数据加密存储
- [ ] 访问控制细化 (字段级权限)
- [ ] 防篡改机制 (区块链/数字签名)
- [ ] 安全审计增强
- [ ] IP白名单
- [ ] 双因素认证 (2FA)

#### 9. 用户体验优化 ⭐⭐
**需要实现的功能**:
- [ ] 界面主题定制 (亮色/暗色)
- [ ] 快捷键支持
- [ ] 拖拽上传
- [ ] 批量拖拽排序
- [ ] 个性化桌面
- [ ] 操作引导和帮助文档

---

## 🛠 技术优化建议

### 1. 架构优化

#### 引入消息队列
**目的**: 异步处理、系统解耦  
**推荐方案**: RabbitMQ / Redis Stream / Kafka

```java
// RabbitMQ配置
@Configuration
public class RabbitMQConfig {
    
    @Bean
    public Queue notificationQueue() {
        return new Queue("archive.notification", true);
    }
    
    @Bean
    public Queue exportQueue() {
        return new Queue("archive.export", true);
    }
    
    @Bean
    public TopicExchange exchange() {
        return new TopicExchange("archive.topic");
    }
}

// 异步消息生产者
@Service
public class AsyncTaskProducer {
    
    @Autowired
    private RabbitTemplate rabbitTemplate;
    
    public void sendExportTask(ExportTask task) {
        rabbitTemplate.convertAndSend(
            "archive.topic", 
            "export.task", 
            task
        );
    }
}

// 消息消费者
@Component
public class ExportTaskConsumer {
    
    @RabbitListener(queues = "archive.export")
    public void handleExportTask(ExportTask task) {
        // 处理导出任务
        exportService.process(task);
    }
}
```

#### 缓存策略优化
**目的**: 提升性能、减少数据库压力  
**推荐方案**: Redis多级缓存

```java
// 多级缓存配置
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(10))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));
        
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .withCacheConfiguration("archive", config.entryTtl(Duration.ofHours(1)))
            .withCacheConfiguration("user", config.entryTtl(Duration.ofMinutes(30)))
            .withCacheConfiguration("config", config.entryTtl(Duration.ofHours(24)))
            .build();
    }
}

// 缓存使用示例
@Service
public class ArchiveService {
    
    @Cacheable(value = "archive", key = "#id")
    public Archive getById(Long id) {
        return archiveMapper.selectById(id);
    }
    
    @CacheEvict(value = "archive", key = "#archive.id")
    public void update(Archive archive) {
        archiveMapper.updateById(archive);
    }
    
    @Caching(evict = {
        @CacheEvict(value = "archive", allEntries = true),
        @CacheEvict(value = "statistics", allEntries = true)
    })
    public void clearCache() {
        // 清除所有缓存
    }
}
```

#### 数据库优化
**目的**: 提升查询性能

```sql
-- 索引优化
CREATE INDEX idx_archive_category_status ON archive(category_id, status);
CREATE INDEX idx_archive_created_time ON archive(created_time);
CREATE INDEX idx_borrow_user_status ON borrow_record(user_id, status);
CREATE INDEX idx_borrow_archive_return_time ON borrow_record(archive_id, return_time);

-- 分区表 (针对大数据量)
ALTER TABLE archive_log PARTITION BY RANGE (YEAR(created_time)) (
    PARTITION p2023 VALUES LESS THAN (2024),
    PARTITION p2024 VALUES LESS THAN (2025),
    PARTITION p2025 VALUES LESS THAN (2026),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);

-- 读写分离配置 (MyBatis-Plus)
@Configuration
public class DataSourceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource.master")
    public DataSource masterDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    @ConfigurationProperties("spring.datasource.slave")
    public DataSource slaveDataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public DataSource dynamicDataSource() {
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put("master", masterDataSource());
        targetDataSources.put("slave", slaveDataSource());
        
        DynamicRoutingDataSource dataSource = new DynamicRoutingDataSource();
        dataSource.setTargetDataSources(targetDataSources);
        dataSource.setDefaultTargetDataSource(masterDataSource());
        
        return dataSource;
    }
}
```

### 2. 性能优化

#### 前端性能优化
```typescript
// 路由懒加载
const routes = [
  {
    path: '/archive',
    component: () => import('@/pages/archive/List.vue')
  }
];

// 组件懒加载
const ArchiveForm = defineAsyncComponent(() => 
  import('@/components/ArchiveForm.vue')
);

// 图片懒加载
<img v-lazy="imageUrl" />

// 虚拟滚动 (大列表)
import { VirtualScroller } from 'vue-virtual-scroller';

<virtual-scroller
  :items="largeList"
  :item-size="50"
  key-field="id"
>
  <template #default="{ item }">
    <div class="item">{{ item.name }}</div>
  </template>
</virtual-scroller>
```

#### 后端性能优化
```java
// 批量操作优化
@Service
public class BatchService {
    
    @Transactional
    public void batchInsert(List<Archive> archives) {
        // 使用批量插入，每次1000条
        int batchSize = 1000;
        for (int i = 0; i < archives.size(); i += batchSize) {
            int end = Math.min(i + batchSize, archives.size());
            archiveMapper.batchInsert(archives.subList(i, end));
        }
    }
}

// 异步任务
@Service
public class AsyncService {
    
    @Async
    public CompletableFuture<ExportResult> exportAsync(ExportRequest request) {
        ExportResult result = exportService.export(request);
        return CompletableFuture.completedFuture(result);
    }
}

// SQL查询优化
@Select("SELECT a.*, c.name as category_name " +
        "FROM archive a " +
        "LEFT JOIN category c ON a.category_id = c.id " +
        "WHERE a.status = #{status} " +
        "LIMIT #{offset}, #{limit}")
List<ArchiveVO> selectWithPagination(@Param("status") String status,
                                      @Param("offset") int offset,
                                      @Param("limit") int limit);
```

### 3. 安全优化

```java
// XSS防护
@Configuration
public class XssConfig {
    
    @Bean
    public FilterRegistrationBean<XssFilter> xssFilterRegistration() {
        FilterRegistrationBean<XssFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new XssFilter());
        registration.addUrlPatterns("/*");
        registration.setName("xssFilter");
        registration.setOrder(1);
        return registration;
    }
}

// CSRF防护
@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf()
            .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse());
    }
}

// SQL注入防护 (使用PreparedStatement)
@Select("SELECT * FROM archive WHERE id = #{id}")
Archive selectById(@Param("id") Long id);

// 敏感数据加密
@Service
public class EncryptionService {
    
    private static final String ALGORITHM = "AES";
    private static final String KEY = "your-secret-key";
    
    public String encrypt(String data) {
        // AES加密实现
    }
    
    public String decrypt(String encryptedData) {
        // AES解密实现
    }
}
```

---

## 📋 实施计划与时间表

### 第一阶段: 基础增强 (1-2个月)

| 任务 | 优先级 | 预计工时 | 负责人 | 开始日期 | 结束日期 |
|------|--------|----------|--------|----------|----------|
| WebSocket实时通知 | P0 | 40小时 | 后端工程师 | 第1周 | 第2周 |
| 消息中心UI | P0 | 24小时 | 前端工程师 | 第2周 | 第3周 |
| 移动端响应式适配 | P0 | 80小时 | 前端工程师 | 第3周 | 第6周 |
| 报表系统基础 | P1 | 60小时 | 全栈工程师 | 第4周 | 第7周 |
| 性能优化 | P1 | 40小时 | 后端工程师 | 第5周 | 第7周 |

**第一阶段目标**:
- ✅ 实时通知系统上线
- ✅ 移动端访问体验良好
- ✅ 基础报表功能可用
- ✅ 系统性能提升30%

### 第二阶段: 功能深化 (2-3个月)

| 任务 | 优先级 | 预计工时 | 负责人 | 开始日期 | 结束日期 |
|------|--------|----------|--------|----------|----------|
| 文档在线预览 | P1 | 60小时 | 全栈工程师 | 第8周 | 第11周 |
| Elasticsearch集成 | P1 | 50小时 | 后端工程师 | 第9周 | 第12周 |
| 系统集成(SSO) | P2 | 40小时 | 后端工程师 | 第10周 | 第12周 |
| 报表系统高级功能 | P1 | 40小时 | 前端工程师 | 第11周 | 第13周 |

**第二阶段目标**:
- ✅ 文档预览支持主流格式
- ✅ 全文检索功能上线
- ✅ SSO集成完成
- ✅ 高级报表功能完善

### 第三阶段: 智能化升级 (3-6个月)

| 任务 | 优先级 | 预计工时 | 负责人 | 开始日期 | 结束日期 |
|------|--------|----------|--------|----------|----------|
| OCR文字识别 | P2 | 50小时 | AI工程师 | 第14周 | 第17周 |
| 智能分类 | P2 | 60小时 | AI工程师 | 第15周 | 第19周 |
| 高级安全功能 | P2 | 40小时 | 安全工程师 | 第16周 | 第19周 |
| 用户体验优化 | P3 | 30小时 | UI/UX设计师 | 第18周 | 第20周 |

**第三阶段目标**:
- ✅ 智能化功能初步可用
- ✅ 安全性进一步提升
- ✅ 用户体验持续优化

---

## 💰 资源需求评估

### 人力资源需求

#### 第一阶段团队
- **后端开发工程师**: 2人 (高级1人 + 中级1人)
  - 技能要求: Spring Boot, Redis, WebSocket, MySQL优化
  - 月薪预算: 2.5万 + 1.8万 = 4.3万
  
- **前端开发工程师**: 2人 (高级1人 + 中级1人)
  - 技能要求: Vue 3, TypeScript, 响应式设计, ECharts
  - 月薪预算: 2.2万 + 1.6万 = 3.8万
  
- **测试工程师**: 1人
  - 技能要求: 自动化测试, 性能测试
  - 月薪预算: 1.5万

**第一阶段人力成本**: (4.3 + 3.8 + 1.5) × 2个月 = **19.2万元**

#### 第二阶段团队 (累加)
- **全栈工程师**: 1人
  - 技能要求: 前后端开发, 系统集成
  - 月薪预算: 2.5万
  
- **DevOps工程师**: 1人
  - 技能要求: Elasticsearch, Docker, K8s
  - 月薪预算: 2.2万

**第二阶段人力成本**: (9.7 + 2.5 + 2.2) × 3个月 = **43.2万元**

#### 第三阶段团队 (累加)
- **AI工程师**: 1人
  - 技能要求: OCR, NLP, 推荐算法
  - 月薪预算: 3.0万
  
- **安全工程师**: 1人
  - 技能要求: 安全审计, 加密技术
  - 月薪预算: 2.5万
  
- **UI/UX设计师**: 1人
  - 技能要求: 界面设计, 用户体验
  - 月薪预算: 1.8万

**第三阶段人力成本**: (14.4 + 3.0 + 2.5 + 1.8) × 4个月 = **87.8万元**

**总人力成本**: 19.2 + 43.2 + 87.8 = **150.2万元**

### 技术资源需求

#### 云服务器
| 环境 | 配置 | 数量 | 单价/月 | 总价/年 |
|------|------|------|---------|---------|
| 开发环境 | 4核8G | 2台 | 200元 | 4,800元 |
| 测试环境 | 8核16G | 2台 | 500元 | 12,000元 |
| 生产环境 | 16核32G | 3台 | 1,200元 | 43,200元 |
| 数据库 | MySQL高可用 | 1套 | 800元 | 9,600元 |
| Redis集群 | 8G内存 | 1套 | 300元 | 3,600元 |
| Elasticsearch | 3节点 | 1套 | 600元 | 7,200元 |
| **小计** | - | - | - | **80,400元/年** |

#### 第三方服务
| 服务 | 用途 | 预计用量 | 单价 | 总价/年 |
|------|------|----------|------|---------|
| 百度OCR | 文字识别 | 10万次/月 | 500元/万次 | 60,000元 |
| 阿里云短信 | 短信通知 | 5千条/月 | 0.05元/条 | 3,000元 |
| 腾讯云邮件 | 邮件推送 | 5万封/月 | 0.002元/封 | 1,200元 |
| CDN加速 | 静态资源 | 500GB/月 | 0.2元/GB | 1,200元 |
| OSS存储 | 文件存储 | 2TB | 0.12元/GB/月 | 2,880元 |
| **小计** | - | - | - | **68,280元/年** |

#### 软件授权
| 软件 | 用途 | 数量 | 单价 | 总价 |
|------|------|------|------|------|
| ONLYOFFICE | 文档预览 | 10用户 | 免费 | 0元 |
| JetBrains全家桶 | 开发工具 | 8份 | 1,000元/年 | 8,000元 |
| **小计** | - | - | - | **8,000元** |

**总技术成本**: 80,400 + 68,280 + 8,000 = **156,680元**

### 总成本汇总
- **人力成本**: 150.2万元
- **技术成本**: 15.7万元
- **其他成本** (培训、差旅等): 5万元
- **总成本**: **170.9万元**

---

## 📊 预期收益分析

### 用户增长预期
- **第一阶段后**: 移动端用户增长30%
- **第二阶段后**: 企业客户增长40%
- **第三阶段后**: 总用户数增长100%

### 收入增长预期
- **SaaS订阅**: 月活用户 × 10元/月 = 新增收入
- **企业定制**: 5个企业客户 × 10万元 = 50万元
- **技术服务**: 年服务费 30万元

**预计年收入增长**: **80-120万元**

### ROI分析
- **投资成本**: 170.9万元
- **预期收益**: 80-120万元/年
- **投资回报周期**: 18-24个月
- **3年总收益**: 240-360万元
- **3年ROI**: 140%-210%

---

## ✅ 成功指标 (KPI)

### 技术指标
- [ ] 系统响应时间 < 200ms
- [ ] 系统可用性 > 99.9%
- [ ] 页面加载时间 < 3秒
- [ ] 移动端适配覆盖率 > 95%
- [ ] API错误率 < 0.1%
- [ ] 代码测试覆盖率 > 80%

### 业务指标
- [ ] 用户满意度 > 4.5/5
- [ ] 日活跃用户增长 > 30%
- [ ] 用户留存率 > 85%
- [ ] 功能使用率 > 70%
- [ ] 客户流失率 < 5%

### 性能指标
- [ ] 并发用户数 > 1000
- [ ] 数据库查询优化 > 50%
- [ ] 缓存命中率 > 90%
- [ ] 文件上传成功率 > 99%

---

## ⚠️ 风险管理

### 技术风险
| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|----------|
| 技术选型不当 | 中 | 高 | 充分调研和POC验证 |
| 第三方服务故障 | 低 | 中 | 多厂商备份方案 |
| 数据库性能瓶颈 | 中 | 高 | 读写分离、分库分表 |
| 安全漏洞 | 低 | 高 | 安全审计和渗透测试 |

### 业务风险
| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|----------|
| 需求频繁变更 | 高 | 中 | 敏捷开发、迭代交付 |
| 竞争加剧 | 中 | 中 | 差异化竞争、快速迭代 |
| 用户流失 | 低 | 高 | 用户反馈机制、持续优化 |

### 资源风险
| 风险 | 概率 | 影响 | 应对措施 |
|------|------|------|----------|
| 人员流失 | 中 | 高 | 知识文档、团队建设 |
| 预算超支 | 中 | 中 | 严格成本控制、分阶段投入 |
| 进度延期 | 中 | 中 | 里程碑管理、敏捷开发 |

---

## 📚 参考资料

### 技术文档
- [Spring Boot官方文档](https://spring.io/projects/spring-boot)
- [Vue 3官方文档](https://vuejs.org/)
- [Element Plus文档](https://element-plus.org/)
- [MyBatis Plus文档](https://baomidou.com/)
- [Redis文档](https://redis.io/documentation)
- [Elasticsearch文档](https://www.elastic.co/guide/)

### 最佳实践
- [阿里巴巴Java开发手册](https://github.com/alibaba/p3c)
- [Vue.js最佳实践](https://vuejs.org/style-guide/)
- [RESTful API设计指南](https://restfulapi.net/)
- [数据库设计规范](https://www.mysql.com/products/enterprise/database.html)

### 工具推荐
- **开发工具**: IntelliJ IDEA, VSCode
- **接口测试**: Postman, Apifox
- **性能测试**: JMeter, LoadRunner
- **监控工具**: Prometheus, Grafana
- **日志分析**: ELK Stack
- **代码质量**: SonarQube

---

## 🎯 总结

### 项目优势
✅ **技术架构先进**: Spring Boot 3 + Vue 3，紧跟技术潮流  
✅ **功能基础扎实**: 核心业务功能完整，代码质量高  
✅ **文档规范完善**: 完整的开发文档和API文档  
✅ **可扩展性强**: 清晰的分层架构，易于扩展

### 主要改进点
🎯 **用户体验**: 移动端适配、实时通知  
🎯 **功能深度**: 文档预览、全文检索、高级报表  
🎯 **智能化**: OCR识别、智能分类  
🎯 **集成能力**: SSO、企业微信、钉钉

### 实施建议
1. **分阶段推进**: 按优先级分三个阶段，每个阶段2-4个月
2. **快速迭代**: 采用敏捷开发，2周一个迭代
3. **用户参与**: 建立用户反馈机制，持续优化
4. **质量保证**: 完善测试体系，确保质量
5. **团队建设**: 加强技术分享，提升团队能力

### 预期成果
✨ 6个月后，系统功能完善度达到 **95%**  
✨ 用户满意度提升到 **4.5/5** 以上  
✨ 市场份额增长到 **15%**  
✨ 成为行业领先的档案管理解决方案

---

**文档维护者**: AI开发助手  
**最后更新**: 2025年10月10日  
**版本**: v1.0  
**状态**: 待审批

---

## 📝 附录A: 代码质量分析

### 当前代码质量状况

#### 1. 代码量统计
- **后端代码**:
  - Java源文件: 324个
  - 代码行数: 约8-10万行 (估算)
  - Controller层: 21个
  - Service层: 35个实现类
  - 工具类: 20+个

- **前端代码**:
  - Vue/TS文件: 147个
  - 页面组件: 30+个
  - 业务组件: 50+个
  - 工具函数: 15+个

#### 2. 待优化项统计
- **TODO标记**: 26处
  - PermissionServiceImpl: 5处
  - NotificationServiceImpl: 3处
  - DepartmentServiceImpl: 8处
  - BorrowController: 4处
  - ExportController: 2处
  - ExportTaskServiceImpl: 2处
  - LoginLogServiceImpl: 1处
  - AuditLogUtil: 1处

- **废弃代码**: 0处 ✅
- **代码重复率**: 估计10-15% (需SonarQube扫描)

#### 3. 优化建议清单

##### 高优先级优化项
1. **PermissionServiceImpl** (5个TODO)
   - 完善权限验证逻辑
   - 优化权限缓存机制
   - 补充权限继承功能
   
2. **DepartmentServiceImpl** (8个TODO)
   - 完善部门树结构构建
   - 优化部门成员查询
   - 补充部门统计功能

3. **BorrowController** (4个TODO)
   - 完善借阅审批流程
   - 优化借阅记录查询
   - 补充逾期提醒功能

##### 中优先级优化项
4. **NotificationServiceImpl** (3个TODO)
   - 完善消息模板系统
   - 优化消息推送策略
   
5. **ExportController & ExportTaskServiceImpl** (4个TODO)
   - 完善大文件导出
   - 优化导出进度追踪

##### 低优先级优化项
6. **LoginLogServiceImpl & AuditLogUtil** (2个TODO)
   - 补充日志清理策略
   - 优化日志查询性能

### 代码重构计划

#### 第一阶段: 清理TODO标记 (2周)
```java
// 示例: PermissionServiceImpl待完成项
@Service
public class PermissionServiceImpl implements PermissionService {
    
    // TODO: 实现权限继承逻辑
    @Override
    public List<Permission> getInheritedPermissions(Long roleId) {
        // 1. 获取角色自身权限
        List<Permission> ownPermissions = getDirectPermissions(roleId);
        
        // 2. 获取父角色权限
        List<Permission> parentPermissions = getParentRolePermissions(roleId);
        
        // 3. 合并去重
        Set<Permission> allPermissions = new HashSet<>();
        allPermissions.addAll(ownPermissions);
        allPermissions.addAll(parentPermissions);
        
        return new ArrayList<>(allPermissions);
    }
    
    // TODO: 实现权限缓存预热
    @PostConstruct
    public void initPermissionCache() {
        // 加载所有角色权限到缓存
        List<Role> allRoles = roleService.list();
        allRoles.forEach(role -> {
            List<Permission> permissions = getDirectPermissions(role.getId());
            cacheService.set("role:permissions:" + role.getId(), permissions);
        });
    }
}
```

#### 第二阶段: 消除代码重复 (2周)
```java
// 重构前: 多处重复的用户验证逻辑
public void methodA() {
    User user = getCurrentUser();
    if (user == null || !user.getEnabled()) {
        throw new UnauthorizedException("用户未登录或已禁用");
    }
    // 业务逻辑...
}

public void methodB() {
    User user = getCurrentUser();
    if (user == null || !user.getEnabled()) {
        throw new UnauthorizedException("用户未登录或已禁用");
    }
    // 业务逻辑...
}

// 重构后: 提取公共方法
@Service
public class UserValidationService {
    
    public User validateAndGetCurrentUser() {
        User user = SecurityContextHolder.getCurrentUser();
        if (user == null) {
            throw new UnauthorizedException("用户未登录");
        }
        if (!user.getEnabled()) {
            throw new UnauthorizedException("用户已禁用");
        }
        return user;
    }
}

// 使用AOP进一步简化
@Aspect
@Component
public class UserValidationAspect {
    
    @Before("@annotation(requireAuth)")
    public void validateUser(RequireAuth requireAuth) {
        userValidationService.validateAndGetCurrentUser();
    }
}

// 使用注解
@RequireAuth
public void methodA() {
    // 业务逻辑，无需重复验证代码
}
```

#### 第三阶段: 性能优化 (3周)
```java
// 优化前: N+1查询问题
public List<ArchiveVO> getArchiveList() {
    List<Archive> archives = archiveMapper.selectAll();
    return archives.stream()
        .map(archive -> {
            ArchiveVO vo = new ArchiveVO();
            // N次查询
            Category category = categoryMapper.selectById(archive.getCategoryId());
            User creator = userMapper.selectById(archive.getCreatorId());
            vo.setCategoryName(category.getName());
            vo.setCreatorName(creator.getUsername());
            return vo;
        })
        .collect(Collectors.toList());
}

// 优化后: 使用JOIN一次性查询
@Select("SELECT a.*, c.name as category_name, u.username as creator_name " +
        "FROM archive a " +
        "LEFT JOIN category c ON a.category_id = c.id " +
        "LEFT JOIN user u ON a.creator_id = u.user_id")
List<ArchiveVO> selectArchivesWithDetails();
```

---

## 📝 附录B: 测试计划

### 单元测试计划

#### 1. 后端单元测试
**目标覆盖率**: 80%以上

**测试框架**: JUnit 5 + Mockito + Spring Boot Test

```java
// Service层测试示例
@SpringBootTest
@AutoConfigureMockMvc
class ArchiveServiceTest {
    
    @Autowired
    private ArchiveService archiveService;
    
    @MockBean
    private ArchiveMapper archiveMapper;
    
    @Test
    @DisplayName("创建档案 - 成功")
    void testCreateArchive_Success() {
        // Given
        Archive archive = new Archive();
        archive.setTitle("测试档案");
        archive.setCategoryId(1L);
        
        when(archiveMapper.insert(any())).thenReturn(1);
        
        // When
        Long archiveId = archiveService.create(archive);
        
        // Then
        assertNotNull(archiveId);
        verify(archiveMapper, times(1)).insert(any());
    }
    
    @Test
    @DisplayName("创建档案 - 标题为空应抛出异常")
    void testCreateArchive_EmptyTitle_ShouldThrowException() {
        // Given
        Archive archive = new Archive();
        archive.setTitle("");
        
        // When & Then
        assertThrows(ValidationException.class, 
            () -> archiveService.create(archive));
    }
    
    @Test
    @DisplayName("分页查询档案")
    void testGetArchiveList_WithPagination() {
        // Given
        Page<Archive> page = new Page<>(1, 10);
        List<Archive> mockData = createMockArchives(10);
        when(archiveMapper.selectPage(any())).thenReturn(mockData);
        
        // When
        PageResult<Archive> result = archiveService.list(page);
        
        // Then
        assertEquals(10, result.getList().size());
        verify(archiveMapper, times(1)).selectPage(any());
    }
}
```

#### 2. 前端单元测试
**目标覆盖率**: 70%以上

**测试框架**: Vitest + Vue Test Utils

```typescript
// 组件测试示例
import { describe, it, expect, vi } from 'vitest';
import { mount } from '@vue/test-utils';
import ArchiveForm from '@/components/ArchiveForm.vue';
import { ElForm, ElInput } from 'element-plus';

describe('ArchiveForm.vue', () => {
  it('应该正确渲染表单', () => {
    const wrapper = mount(ArchiveForm, {
      global: {
        components: { ElForm, ElInput }
      }
    });
    
    expect(wrapper.find('form').exists()).toBe(true);
    expect(wrapper.find('input[name="title"]').exists()).toBe(true);
  });
  
  it('提交空表单应显示验证错误', async () => {
    const wrapper = mount(ArchiveForm);
    
    await wrapper.find('form').trigger('submit');
    
    expect(wrapper.find('.error-message').text()).toContain('标题不能为空');
  });
  
  it('提交有效表单应调用API', async () => {
    const mockSubmit = vi.fn();
    const wrapper = mount(ArchiveForm, {
      props: {
        onSubmit: mockSubmit
      }
    });
    
    await wrapper.find('input[name="title"]').setValue('测试档案');
    await wrapper.find('form').trigger('submit');
    
    expect(mockSubmit).toHaveBeenCalledWith({
      title: '测试档案'
    });
  });
});
```

### 集成测试计划

#### 1. API集成测试
```java
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@AutoConfigureMockMvc
class ArchiveControllerIntegrationTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @Autowired
    private ObjectMapper objectMapper;
    
    @Test
    @DisplayName("完整的档案创建流程测试")
    void testArchiveCreationWorkflow() throws Exception {
        // 1. 登录获取token
        String token = loginAndGetToken("admin", "admin123");
        
        // 2. 创建档案
        ArchiveRequest request = new ArchiveRequest();
        request.setTitle("集成测试档案");
        request.setCategoryId(1L);
        
        MvcResult result = mockMvc.perform(post("/api/archives")
                .header("Authorization", "Bearer " + token)
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(request)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.id").exists())
            .andReturn();
        
        // 3. 验证档案已创建
        Long archiveId = extractArchiveId(result);
        
        mockMvc.perform(get("/api/archives/" + archiveId)
                .header("Authorization", "Bearer " + token))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.data.title").value("集成测试档案"));
    }
}
```

#### 2. E2E测试计划 (Playwright)
```typescript
// tests/e2e/archive-workflow.spec.ts
import { test, expect } from '@playwright/test';

test.describe('档案管理完整流程', () => {
  test.beforeEach(async ({ page }) => {
    // 登录
    await page.goto('http://localhost:3000/login');
    await page.fill('input[name="username"]', 'admin');
    await page.fill('input[name="password"]', 'admin123');
    await page.click('button[type="submit"]');
    await page.waitForURL('**/dashboard');
  });
  
  test('应该能够创建、查看、编辑和删除档案', async ({ page }) => {
    // 1. 创建档案
    await page.goto('http://localhost:3000/archive/add');
    await page.fill('input[name="title"]', 'E2E测试档案');
    await page.selectOption('select[name="category"]', '1');
    await page.click('button:has-text("提交")');
    
    // 等待创建成功消息
    await expect(page.locator('.el-message--success')).toBeVisible();
    
    // 2. 查看档案列表
    await page.goto('http://localhost:3000/archive/list');
    await expect(page.locator('text=E2E测试档案')).toBeVisible();
    
    // 3. 编辑档案
    await page.click('text=E2E测试档案 >> xpath=../.. >> button:has-text("编辑")');
    await page.fill('input[name="title"]', 'E2E测试档案(已修改)');
    await page.click('button:has-text("保存")');
    
    await expect(page.locator('.el-message--success')).toBeVisible();
    
    // 4. 删除档案
    await page.goto('http://localhost:3000/archive/list');
    await page.click('text=E2E测试档案(已修改) >> xpath=../.. >> button:has-text("删除")');
    await page.click('button:has-text("确认")');
    
    await expect(page.locator('text=E2E测试档案(已修改)')).not.toBeVisible();
  });
});
```

### 性能测试计划

#### 1. JMeter压力测试脚本
```xml
<!-- jmeter-test-plan.jmx -->
<jmeterTestPlan version="1.2">
  <ThreadGroup>
    <stringProp name="ThreadGroup.num_threads">100</stringProp>
    <stringProp name="ThreadGroup.ramp_time">10</stringProp>
    <stringProp name="ThreadGroup.duration">300</stringProp>
    
    <!-- 登录请求 -->
    <HTTPSamplerProxy>
      <stringProp name="HTTPSampler.path">/api/auth/login</stringProp>
      <stringProp name="HTTPSampler.method">POST</stringProp>
      <boolProp name="HTTPSampler.use_keepalive">true</boolProp>
    </HTTPSamplerProxy>
    
    <!-- 查询档案列表 -->
    <HTTPSamplerProxy>
      <stringProp name="HTTPSampler.path">/api/archives?page=1&size=20</stringProp>
      <stringProp name="HTTPSampler.method">GET</stringProp>
    </HTTPSamplerProxy>
    
    <!-- 查看档案详情 -->
    <HTTPSamplerProxy>
      <stringProp name="HTTPSampler.path">/api/archives/${archiveId}</stringProp>
      <stringProp name="HTTPSampler.method">GET</stringProp>
    </HTTPSamplerProxy>
  </ThreadGroup>
  
  <!-- 断言 -->
  <ResponseAssertion>
    <stringProp name="Assertion.test_field">Assertion.response_time</stringProp>
    <stringProp name="Assertion.test_type">16</stringProp>
    <stringProp name="Assertion.custom_message">响应时间应小于200ms</stringProp>
    <longProp name="Assertion.expected_value">200</longProp>
  </ResponseAssertion>
</jmeterTestPlan>
```

#### 2. 性能测试指标
| 测试场景 | 并发用户数 | 平均响应时间 | 95%响应时间 | TPS | 错误率 |
|---------|-----------|-------------|------------|-----|-------|
| 档案列表查询 | 100 | <150ms | <300ms | >500 | <1% |
| 档案详情查询 | 100 | <100ms | <200ms | >800 | <1% |
| 档案创建 | 50 | <500ms | <1000ms | >100 | <1% |
| 文件上传 | 20 | <2000ms | <5000ms | >10 | <2% |
| 全文搜索 | 100 | <200ms | <400ms | >400 | <1% |

---

## 📝 附录C: 部署文档

### Docker部署指南

#### 1. Dockerfile优化
```dockerfile
# 多阶段构建 - 后端
FROM maven:3.8-openjdk-17 AS backend-builder
WORKDIR /app
COPY pom.xml .
RUN mvn dependency:go-offline
COPY src ./src
RUN mvn clean package -DskipTests

# 多阶段构建 - 前端
FROM node:18-alpine AS frontend-builder
WORKDIR /app
COPY frontend/package*.json ./
RUN npm ci --only=production
COPY frontend/ .
RUN npm run build

# 最终镜像 - 后端
FROM openjdk:17-jre-slim
WORKDIR /app

# 添加非root用户
RUN groupadd -r appuser && useradd -r -g appuser appuser

# 复制jar包
COPY --from=backend-builder /app/target/*.jar app.jar

# 复制前端构建产物
COPY --from=frontend-builder /app/dist /app/static

# 安装健康检查工具
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# 设置权限
RUN chown -R appuser:appuser /app
USER appuser

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --start-period=60s --retries=3 \
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# 暴露端口
EXPOSE 8080

# JVM参数优化
ENV JAVA_OPTS="-Xms512m -Xmx2g -XX:+UseG1GC -XX:MaxGCPauseMillis=200 \
               -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/app/logs"

# 启动命令
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

#### 2. Docker Compose完整配置
```yaml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: archive-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: archive_management
      MYSQL_USER: archive_user
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
      TZ: Asia/Shanghai
    volumes:
      - mysql-data:/var/lib/mysql
      - ./database:/docker-entrypoint-initdb.d:ro
      - ./mysql-conf:/etc/mysql/conf.d:ro
    ports:
      - "3306:3306"
    command: 
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci
      - --max_connections=500
      - --innodb_buffer_pool_size=1G
    healthcheck:
      test: ["CMD", "mysqladmin", "ping", "-h", "localhost"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - archive-network

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: archive-redis
    restart: unless-stopped
    command: redis-server --requirepass ${REDIS_PASSWORD} --maxmemory 512mb --maxmemory-policy allkeys-lru
    volumes:
      - redis-data:/data
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
    networks:
      - archive-network

  # Elasticsearch
  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.10.0
    container_name: archive-elasticsearch
    restart: unless-stopped
    environment:
      - discovery.type=single-node
      - "ES_JAVA_OPTS=-Xms512m -Xmx512m"
      - xpack.security.enabled=false
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    ports:
      - "9200:9200"
      - "9300:9300"
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:9200/_cluster/health || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
    networks:
      - archive-network

  # 后端应用
  backend:
    build:
      context: .
      dockerfile: Dockerfile.backend
    container_name: archive-backend
    restart: unless-stopped
    depends_on:
      mysql:
        condition: service_healthy
      redis:
        condition: service_healthy
    environment:
      SPRING_PROFILES_ACTIVE: prod
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/archive_management?useSSL=false&serverTimezone=Asia/Shanghai
      SPRING_DATASOURCE_USERNAME: archive_user
      SPRING_DATASOURCE_PASSWORD: ${MYSQL_PASSWORD}
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PASSWORD: ${REDIS_PASSWORD}
      ELASTICSEARCH_HOST: elasticsearch
      JWT_SECRET: ${JWT_SECRET}
    volumes:
      - ./uploads:/app/uploads
      - ./logs:/app/logs
    ports:
      - "8080:8080"
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/actuator/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 60s
    networks:
      - archive-network

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: archive-nginx
    restart: unless-stopped
    depends_on:
      - backend
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./frontend/dist:/usr/share/nginx/html:ro
      - ./ssl:/etc/nginx/ssl:ro
      - nginx-logs:/var/log/nginx
    ports:
      - "80:80"
      - "443:443"
    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/health"]
      interval: 30s
      timeout: 10s
      retries: 3
    networks:
      - archive-network

  # Prometheus监控
  prometheus:
    image: prom/prometheus:latest
    container_name: archive-prometheus
    restart: unless-stopped
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml:ro
      - prometheus-data:/prometheus
    ports:
      - "9090:9090"
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
      - '--storage.tsdb.retention.time=30d'
    networks:
      - archive-network

  # Grafana可视化
  grafana:
    image: grafana/grafana:latest
    container_name: archive-grafana
    restart: unless-stopped
    depends_on:
      - prometheus
    environment:
      GF_SECURITY_ADMIN_PASSWORD: ${GRAFANA_PASSWORD}
      GF_INSTALL_PLUGINS: grafana-clock-panel
    volumes:
      - grafana-data:/var/lib/grafana
      - ./monitoring/grafana-datasources.yml:/etc/grafana/provisioning/datasources/datasources.yml:ro
      - ./monitoring/grafana-dashboard.json:/etc/grafana/provisioning/dashboards/dashboard.json:ro
    ports:
      - "3001:3000"
    networks:
      - archive-network

volumes:
  mysql-data:
  redis-data:
  elasticsearch-data:
  prometheus-data:
  grafana-data:
  nginx-logs:

networks:
  archive-network:
    driver: bridge
```

#### 3. 环境变量配置 (.env)
```env
# 数据库配置
MYSQL_ROOT_PASSWORD=your_secure_root_password
MYSQL_PASSWORD=your_secure_user_password

# Redis配置
REDIS_PASSWORD=your_secure_redis_password

# JWT配置
JWT_SECRET=your_very_long_and_secure_jwt_secret_key_here

# Grafana配置
GRAFANA_PASSWORD=your_secure_grafana_password

# 应用配置
APP_ENV=production
APP_DEBUG=false
APP_LOG_LEVEL=info
```

### Kubernetes部署配置

#### 1. Deployment配置
```yaml
# k8s/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: archive-backend
  namespace: archive-system
  labels:
    app: archive-backend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: archive-backend
  template:
    metadata:
      labels:
        app: archive-backend
    spec:
      containers:
      - name: backend
        image: archive-system:latest
        imagePullPolicy: IfNotPresent
        ports:
        - containerPort: 8080
          name: http
          protocol: TCP
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            configMapKeyRef:
              name: archive-config
              key: database-url
        - name: SPRING_DATASOURCE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: archive-secrets
              key: database-password
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /actuator/health/liveness
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        volumeMounts:
        - name: uploads
          mountPath: /app/uploads
        - name: logs
          mountPath: /app/logs
      volumes:
      - name: uploads
        persistentVolumeClaim:
          claimName: archive-uploads-pvc
      - name: logs
        persistentVolumeClaim:
          claimName: archive-logs-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: archive-backend-service
  namespace: archive-system
spec:
  type: ClusterIP
  selector:
    app: archive-backend
  ports:
  - port: 8080
    targetPort: 8080
    protocol: TCP
    name: http
---
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: archive-ingress
  namespace: archive-system
  annotations:
    kubernetes.io/ingress.class: "nginx"
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
spec:
  tls:
  - hosts:
    - archive.example.com
    secretName: archive-tls
  rules:
  - host: archive.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: archive-backend-service
            port:
              number: 8080
```

---

## 📝 附录D: 监控与告警配置

### Prometheus配置
```yaml
# monitoring/prometheus.yml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

alerting:
  alertmanagers:
    - static_configs:
        - targets:
            - 'alertmanager:9093'

rule_files:
  - "/etc/prometheus/alert_rules.yml"

scrape_configs:
  # Spring Boot应用监控
  - job_name: 'archive-backend'
    metrics_path: '/actuator/prometheus'
    static_configs:
      - targets: ['backend:8080']
        labels:
          service: 'archive-backend'
  
  # MySQL监控
  - job_name: 'mysql'
    static_configs:
      - targets: ['mysql-exporter:9104']
        labels:
          service: 'mysql'
  
  # Redis监控
  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
        labels:
          service: 'redis'
  
  # Nginx监控
  - job_name: 'nginx'
    static_configs:
      - targets: ['nginx-exporter:9113']
        labels:
          service: 'nginx'
```

### 告警规则配置
```yaml
# monitoring/alert_rules.yml
groups:
  - name: application_alerts
    interval: 30s
    rules:
      # 应用响应时间告警
      - alert: HighResponseTime
        expr: http_server_requests_seconds_sum{job="archive-backend"} / http_server_requests_seconds_count{job="archive-backend"} > 1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "高响应时间告警"
          description: "{{ $labels.instance }} 平均响应时间超过1秒"
      
      # 错误率告警
      - alert: HighErrorRate
        expr: rate(http_server_requests_seconds_count{status=~"5.."}[5m]) > 0.05
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "高错误率告警"
          description: "{{ $labels.instance }} 错误率超过5%"
      
      # CPU使用率告警
      - alert: HighCPUUsage
        expr: process_cpu_usage{job="archive-backend"} > 0.8
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "CPU使用率过高"
          description: "{{ $labels.instance }} CPU使用率超过80%"
      
      # 内存使用告警
      - alert: HighMemoryUsage
        expr: jvm_memory_used_bytes{area="heap"} / jvm_memory_max_bytes{area="heap"} > 0.85
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "内存使用率过高"
          description: "{{ $labels.instance }} 堆内存使用超过85%"
      
      # 数据库连接池告警
      - alert: DatabaseConnectionPoolExhausted
        expr: hikaricp_connections_active / hikaricp_connections_max > 0.9
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "数据库连接池告警"
          description: "{{ $labels.instance }} 连接池使用率超过90%"

  - name: infrastructure_alerts
    interval: 30s
    rules:
      # MySQL可用性
      - alert: MySQLDown
        expr: up{job="mysql"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "MySQL服务不可用"
          description: "MySQL实例 {{ $labels.instance }} 已宕机"
      
      # Redis可用性
      - alert: RedisDown
        expr: up{job="redis"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Redis服务不可用"
          description: "Redis实例 {{ $labels.instance }} 已宕机"
      
      # 磁盘空间告警
      - alert: DiskSpaceWarning
        expr: (node_filesystem_avail_bytes / node_filesystem_size_bytes) < 0.2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "磁盘空间不足"
          description: "{{ $labels.instance }} 磁盘剩余空间少于20%"
```

### Grafana Dashboard配置
```json
{
  "dashboard": {
    "title": "档案管理系统监控面板",
    "panels": [
      {
        "title": "API请求量 (QPS)",
        "targets": [
          {
            "expr": "rate(http_server_requests_seconds_count[1m])",
            "legendFormat": "{{method}} {{uri}}"
          }
        ]
      },
      {
        "title": "API响应时间 (P95)",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(http_server_requests_seconds_bucket[5m]))",
            "legendFormat": "{{method}} {{uri}}"
          }
        ]
      },
      {
        "title": "错误率",
        "targets": [
          {
            "expr": "rate(http_server_requests_seconds_count{status=~\"5..\"}[5m])",
            "legendFormat": "5xx错误"
          }
        ]
      },
      {
        "title": "JVM内存使用",
        "targets": [
          {
            "expr": "jvm_memory_used_bytes{area=\"heap\"}",
            "legendFormat": "Heap使用量"
          },
          {
            "expr": "jvm_memory_max_bytes{area=\"heap\"}",
            "legendFormat": "Heap最大值"
          }
        ]
      },
      {
        "title": "数据库连接池",
        "targets": [
          {
            "expr": "hikaricp_connections_active",
            "legendFormat": "活跃连接"
          },
          {
            "expr": "hikaricp_connections_idle",
            "legendFormat": "空闲连接"
          }
        ]
      }
    ]
  }
}
```

---

## 📝 附录E: 安全加固指南

### 1. 应用层安全

#### HTTPS配置
```nginx
# nginx-ssl.conf
server {
    listen 80;
    server_name archive.example.com;
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name archive.example.com;
    
    # SSL证书配置
    ssl_certificate /etc/nginx/ssl/fullchain.pem;
    ssl_certificate_key /etc/nginx/ssl/privkey.pem;
    
    # SSL优化配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256';
    ssl_prefer_server_ciphers on;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    
    # 安全头配置
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';" always;
    
    location / {
        proxy_pass http://backend:8080;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

#### 防火墙规则
```bash
# firewall-rules.sh
#!/bin/bash

# 允许SSH
ufw allow 22/tcp

# 允许HTTP/HTTPS
ufw allow 80/tcp
ufw allow 443/tcp

# 限制数据库访问（仅允许应用服务器）
ufw allow from 172.18.0.0/24 to any port 3306
ufw allow from 172.18.0.0/24 to any port 6379

# 启用防火墙
ufw --force enable

# 配置fail2ban
cat > /etc/fail2ban/jail.local <<EOF
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 5

[sshd]
enabled = true

[nginx-http-auth]
enabled = true
EOF

systemctl restart fail2ban
```

### 2. 数据库安全

#### MySQL安全配置
```sql
-- mysql-security.sql

-- 删除匿名用户
DELETE FROM mysql.user WHERE User='';

-- 删除test数据库
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';

-- 禁止root远程登录
DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');

-- 创建应用专用用户（限制权限）
CREATE USER IF NOT EXISTS 'archive_user'@'172.18.0.%' IDENTIFIED BY 'secure_password';
GRANT SELECT, INSERT, UPDATE, DELETE ON archive_management.* TO 'archive_user'@'172.18.0.%';

-- 刷新权限
FLUSH PRIVILEGES;

-- 启用审计日志
SET GLOBAL general_log = 'ON';
SET GLOBAL log_output = 'TABLE';
```

#### Redis安全配置
```conf
# redis-security.conf

# 设置强密码
requirepass your_very_secure_redis_password_here

# 绑定到内网IP
bind 127.0.0.1 172.18.0.1

# 禁用危险命令
rename-command FLUSHDB ""
rename-command FLUSHALL ""
rename-command CONFIG ""
rename-command SHUTDOWN ""

# 启用持久化
save 900 1
save 300 10
save 60 10000

# 设置最大内存
maxmemory 512mb
maxmemory-policy allkeys-lru
```

### 3. 应用安全配置

#### Spring Security增强
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            // CSRF防护
            .csrf()
                .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
            .and()
            
            // 点击劫持防护
            .headers()
                .frameOptions().deny()
                .xssProtection().and()
                .contentSecurityPolicy("default-src 'self'")
            .and()
            
            // 会话管理
            .sessionManagement()
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
                .maximumSessions(1)
                .maxSessionsPreventsLogin(true)
            .and()
            .and()
            
            // 授权配置
            .authorizeHttpRequests()
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .anyRequest().authenticated()
            .and()
            
            // JWT过滤器
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        // 使用BCrypt强密码编码
        return new BCryptPasswordEncoder(12);
    }
}
```

#### 输入验证
```java
@RestController
@Validated
public class ArchiveController {
    
    @PostMapping("/archives")
    public Result<Archive> create(
        @RequestBody @Valid ArchiveRequest request) {
        
        // 使用Hibernate Validator验证
        return Result.success(archiveService.create(request));
    }
}

@Data
public class ArchiveRequest {
    
    @NotBlank(message = "标题不能为空")
    @Size(min = 1, max = 200, message = "标题长度必须在1-200之间")
    @Pattern(regexp = "^[\\u4e00-\\u9fa5a-zA-Z0-9\\s]+$", message = "标题只能包含中文、字母、数字和空格")
    private String title;
    
    @NotNull(message = "分类ID不能为空")
    @Min(value = 1, message = "无效的分类ID")
    private Long categoryId;
    
    @Size(max = 1000, message = "描述不能超过1000字")
    private String description;
}
```

---

## 📝 附录F: 故障排查指南

### 常见问题与解决方案

#### 1. 数据库连接问题

**症状**: 应用无法连接到MySQL

**排查步骤**:
```bash
# 1. 检查MySQL服务状态
docker exec archive-mysql mysqladmin ping -h localhost -p

# 2. 检查网络连通性
docker exec archive-backend ping mysql

# 3. 检查数据库配置
docker exec archive-backend env | grep SPRING_DATASOURCE

# 4. 查看数据库日志
docker logs archive-mysql --tail 100

# 5. 验证用户权限
docker exec -it archive-mysql mysql -uroot -p
> SHOW GRANTS FOR 'archive_user'@'%';
```

**解决方案**:
- 确保MySQL容器正常运行
- 检查数据库密码是否正确
- 验证网络连接（Docker网络）
- 检查防火墙规则

#### 2. Redis缓存问题

**症状**: 缓存失效或响应慢

**排查步骤**:
```bash
# 1. 检查Redis状态
docker exec archive-redis redis-cli -a ${REDIS_PASSWORD} ping

# 2. 查看内存使用
docker exec archive-redis redis-cli -a ${REDIS_PASSWORD} info memory

# 3. 检查缓存命中率
docker exec archive-redis redis-cli -a ${REDIS_PASSWORD} info stats | grep keyspace

# 4. 监控命令执行
docker exec archive-redis redis-cli -a ${REDIS_PASSWORD} monitor
```

**解决方案**:
- 检查Redis内存配置
- 优化缓存过期策略
- 调整maxmemory-policy
- 实施缓存预热

#### 3. 应用性能问题

**症状**: 响应时间过长

**排查步骤**:
```bash
# 1. 检查JVM内存
docker exec archive-backend jstat -gc 1

# 2. 生成线程dump
docker exec archive-backend jstack 1 > thread_dump.txt

# 3. 生成堆dump
docker exec archive-backend jmap -dump:live,format=b,file=/app/logs/heap_dump.hprof 1

# 4. 查看慢查询日志
docker exec archive-mysql mysql -uroot -p -e "SELECT * FROM mysql.slow_log ORDER BY start_time DESC LIMIT 10"
```

**解决方案**:
- 分析线程dump找出阻塞点
- 使用MAT分析堆dump
- 优化慢SQL查询
- 增加应用实例

---

**文档维护者**: AI开发助手  
**最后更新**: 2025年10月10日  
**版本**: v2.0 (已完善)  
**状态**: 已完善，待审批

