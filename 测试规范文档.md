# 档案管理系统 - 测试规范文档

**版本**: v1.0  
**创建日期**: 2025年10月15日  
**负责人**: 开发团队  
**状态**: 正式发布

---

## 目录

1. [概述](#概述)
2. [测试策略](#测试策略)
3. [后端测试规范](#后端测试规范)
4. [前端测试规范](#前端测试规范)
5. [测试编写指南](#测试编写指南)
6. [最佳实践](#最佳实践)
7. [代码覆盖率要求](#代码覆盖率要求)
8. [测试命名规范](#测试命名规范)
9. [Mock与Stub使用指南](#mock与stub使用指南)
10. [CI/CD集成](#cicd集成)
11. [常见问题与解决方案](#常见问题与解决方案)
12. [附录](#附录)

---

## 概述

### 1.1 文档目的

本文档旨在为档案管理系统的开发团队提供统一的测试规范和最佳实践指南，确保：
- 代码质量稳定可靠
- 测试覆盖率达标
- 测试代码可维护性高
- 团队协作效率提升

### 1.2 适用范围

本规范适用于档案管理系统的所有测试代码，包括：
- 后端单元测试（JUnit 5 + Mockito）
- 后端集成测试（Spring Boot Test + H2）
- 前端单元测试（Vitest + Vue Test Utils）
- 前端组件测试
- E2E测试（Playwright，可选）

### 1.3 测试金字塔原则

我们遵循测试金字塔原则，测试类型分布如下：

```
        /\
       /  \      E2E测试 (10%)
      /____\     
     /      \    集成测试 (20%)
    /________\   
   /          \  单元测试 (70%)
  /____________\ 
```

- **单元测试 (70%)**：快速、独立、针对单个函数/类
- **集成测试 (20%)**：测试模块间交互、数据库操作
- **E2E测试 (10%)**：端到端业务流程验证

---

## 测试策略

### 2.1 测试目标

| 指标 | 目标值 | 当前值 | 截止日期 |
|------|--------|--------|----------|
| 后端代码覆盖率 | ≥80% | 待测量 | 第5周末 |
| 前端代码覆盖率 | ≥70% | 0% | 第5周末 |
| 单元测试通过率 | 100% | 100% | 持续 |
| 集成测试通过率 | 100% | 待测量 | 第3周末 |
| 测试执行时间 | <5分钟 | 待测量 | 第4周末 |

### 2.2 测试分层策略

#### 2.2.1 后端测试分层

```
┌─────────────────────────────────────┐
│  E2E测试 (可选)                      │
│  - API端到端流程测试                 │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│  集成测试                            │
│  - Controller层测试                  │
│  - Service层集成测试                 │
│  - Repository层测试                  │
│  - 消息队列集成测试                  │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│  单元测试                            │
│  - Service业务逻辑测试               │
│  - Util工具类测试                    │
│  - Validator验证器测试               │
│  - Mapper转换器测试                  │
└─────────────────────────────────────┘
```

#### 2.2.2 前端测试分层

```
┌─────────────────────────────────────┐
│  E2E测试 (Playwright)                │
│  - 用户登录流程                      │
│  - 档案借阅流程                      │
│  - 权限管理流程                      │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│  组件测试                            │
│  - 业务组件测试                      │
│  - 通用组件测试                      │
│  - 表单交互测试                      │
└─────────────────────────────────────┘
┌─────────────────────────────────────┐
│  单元测试                            │
│  - Store状态管理测试                 │
│  - Composable逻辑测试                │
│  - Utils工具函数测试                 │
│  - API模块测试                       │
└─────────────────────────────────────┘
```

### 2.3 测试优先级

#### P0 - 必须测试（第1-3周）
- ✅ 核心业务逻辑（档案CRUD、借阅归还）
- ✅ 权限验证和安全相关
- ✅ 数据持久化操作
- ✅ 关键工具函数

#### P1 - 应该测试（第4-5周）
- 📋 次要业务逻辑
- 📋 UI组件交互
- 📋 状态管理
- 📋 API调用

#### P2 - 可以测试（第6-8周）
- 📋 边界情况
- 📋 性能测试
- 📋 兼容性测试

---

## 后端测试规范

### 3.1 技术栈

- **测试框架**: JUnit 5 (Jupiter)
- **Mock框架**: Mockito
- **断言库**: AssertJ + JUnit Assertions
- **覆盖率工具**: JaCoCo
- **测试数据库**: H2 (内存数据库)
- **Spring测试**: Spring Boot Test

### 3.2 项目结构

```
src/test/java/com/archive/management/
├── BaseTest.java                    # 测试基类
├── BaseIntegrationTest.java         # 集成测试基类
├── TestDataFactory.java             # 测试数据工厂
├── config/                          # 测试配置
│   └── TestConfig.java
├── controller/                      # Controller测试
│   ├── ArchiveControllerTest.java
│   └── UserControllerTest.java
├── service/                         # Service单元测试
│   ├── ArchiveServiceTest.java
│   └── UserServiceTest.java
├── integration/                     # 集成测试
│   ├── ArchiveIntegrationTest.java
│   └── BorrowIntegrationTest.java
├── repository/                      # Repository测试
│   └── ArchiveRepositoryTest.java
└── util/                           # 工具类测试
    └── DateUtilTest.java
```

### 3.3 测试基类使用

#### 3.3.1 BaseTest - 通用测试基类

所有测试类都应继承 `BaseTest`，它提供：

```java
@ExtendWith(SpringExtension.class)
@SpringBootTest
@ActiveProfiles("test")
@Transactional
@AutoConfigureTestEntityManager
@TestPropertySource(properties = {
    "spring.jpa.show-sql=false",
    "logging.level.org.hibernate.SQL=WARN"
})
public abstract class BaseTest {
    
    @Autowired
    protected TestEntityManager entityManager;
    
    // 测试数据准备方法
    protected Department createTestDepartment(String name) { ... }
    protected Role createTestRole(String name) { ... }
    protected User createTestUser(String username) { ... }
    protected Archive createTestArchive(String title) { ... }
    
    // 测试数据清理方法
    @AfterEach
    public void cleanup() { ... }
}
```

**使用示例**：

```java
@DisplayName("档案服务测试")
class ArchiveServiceTest extends BaseTest {
    
    @Autowired
    private ArchiveService archiveService;
    
    @Test
    @DisplayName("应该成功创建档案")
    void shouldCreateArchive() {
        // Given
        Archive archive = createTestArchive("测试档案");
        
        // When
        Archive saved = archiveService.create(archive);
        
        // Then
        assertThat(saved.getId()).isNotNull();
        assertThat(saved.getTitle()).isEqualTo("测试档案");
    }
}
```

### 3.4 单元测试规范

#### 3.4.1 Service层测试

**测试重点**：
- 业务逻辑正确性
- 异常处理
- 边界条件
- 权限验证

**示例**：

```java
@DisplayName("档案服务单元测试")
class ArchiveServiceTest extends BaseTest {
    
    @Autowired
    private ArchiveService archiveService;
    
    @MockBean
    private ArchiveRepository archiveRepository;
    
    @MockBean
    private UserService userService;
    
    @Test
    @DisplayName("创建档案 - 成功场景")
    void createArchive_Success() {
        // Given: 准备测试数据
        ArchiveCreateDTO dto = ArchiveCreateDTO.builder()
            .title("测试档案")
            .categoryId(1L)
            .content("档案内容")
            .build();
        
        User currentUser = createTestUser("testuser");
        when(userService.getCurrentUser()).thenReturn(currentUser);
        
        Archive expectedArchive = new Archive();
        expectedArchive.setId(1L);
        expectedArchive.setTitle(dto.getTitle());
        when(archiveRepository.save(any(Archive.class))).thenReturn(expectedArchive);
        
        // When: 执行测试方法
        Archive result = archiveService.create(dto);
        
        // Then: 验证结果
        assertThat(result).isNotNull();
        assertThat(result.getId()).isEqualTo(1L);
        assertThat(result.getTitle()).isEqualTo("测试档案");
        
        // 验证方法调用
        verify(archiveRepository, times(1)).save(any(Archive.class));
        verify(userService, times(1)).getCurrentUser();
    }
    
    @Test
    @DisplayName("创建档案 - 标题为空应抛出异常")
    void createArchive_EmptyTitle_ShouldThrowException() {
        // Given
        ArchiveCreateDTO dto = ArchiveCreateDTO.builder()
            .title("")
            .categoryId(1L)
            .build();
        
        // When & Then
        assertThatThrownBy(() -> archiveService.create(dto))
            .isInstanceOf(ValidationException.class)
            .hasMessageContaining("标题不能为空");
    }
    
    @Test
    @DisplayName("删除档案 - 无权限应抛出异常")
    void deleteArchive_NoPermission_ShouldThrowException() {
        // Given
        Archive archive = createTestArchive("测试档案");
        User currentUser = createTestUser("otheruser");
        
        when(archiveRepository.findById(1L)).thenReturn(Optional.of(archive));
        when(userService.getCurrentUser()).thenReturn(currentUser);
        when(userService.hasPermission(currentUser, "archive:delete")).thenReturn(false);
        
        // When & Then
        assertThatThrownBy(() -> archiveService.delete(1L))
            .isInstanceOf(PermissionDeniedException.class)
            .hasMessageContaining("无权限删除档案");
    }
}
```

#### 3.4.2 Util工具类测试

**测试重点**：
- 各种输入情况
- 边界值
- 异常情况
- null处理

**示例**：

```java
@DisplayName("日期工具类测试")
class DateUtilTest {
    
    @Test
    @DisplayName("格式化日期 - 标准格式")
    void formatDate_StandardFormat() {
        // Given
        LocalDateTime date = LocalDateTime.of(2024, 1, 15, 10, 30, 0);
        
        // When
        String result = DateUtil.format(date, "yyyy-MM-dd HH:mm:ss");
        
        // Then
        assertThat(result).isEqualTo("2024-01-15 10:30:00");
    }
    
    @Test
    @DisplayName("格式化日期 - null应返回空字符串")
    void formatDate_Null_ShouldReturnEmpty() {
        // When
        String result = DateUtil.format(null, "yyyy-MM-dd");
        
        // Then
        assertThat(result).isEmpty();
    }
    
    @ParameterizedTest
    @DisplayName("解析日期 - 多种格式")
    @CsvSource({
        "2024-01-15, yyyy-MM-dd",
        "2024/01/15, yyyy/MM/dd",
        "20240115, yyyyMMdd"
    })
    void parseDate_VariousFormats(String dateStr, String pattern) {
        // When
        LocalDate result = DateUtil.parse(dateStr, pattern);
        
        // Then
        assertThat(result).isEqualTo(LocalDate.of(2024, 1, 15));
    }
}
```

### 3.5 集成测试规范

#### 3.5.1 Controller层测试

**测试重点**：
- HTTP请求/响应
- 参数验证
- 权限控制
- 异常处理

**示例**：

```java
@DisplayName("档案控制器集成测试")
@WebMvcTest(ArchiveController.class)
class ArchiveControllerTest extends BaseTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private ArchiveService archiveService;
    
    @Test
    @DisplayName("GET /api/archives/{id} - 成功获取档案")
    @WithMockUser(username = "testuser", roles = {"USER"})
    void getArchive_Success() throws Exception {
        // Given
        Archive archive = createTestArchive("测试档案");
        archive.setId(1L);
        when(archiveService.findById(1L)).thenReturn(archive);
        
        // When & Then
        mockMvc.perform(get("/api/archives/1")
                .contentType(MediaType.APPLICATION_JSON))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.id").value(1))
            .andExpect(jsonPath("$.data.title").value("测试档案"))
            .andDo(print());
    }
    
    @Test
    @DisplayName("POST /api/archives - 创建档案成功")
    @WithMockUser(username = "testuser", roles = {"ADMIN"})
    void createArchive_Success() throws Exception {
        // Given
        ArchiveCreateDTO dto = ArchiveCreateDTO.builder()
            .title("新档案")
            .categoryId(1L)
            .content("档案内容")
            .build();
        
        Archive savedArchive = new Archive();
        savedArchive.setId(1L);
        savedArchive.setTitle(dto.getTitle());
        
        when(archiveService.create(any(ArchiveCreateDTO.class))).thenReturn(savedArchive);
        
        // When & Then
        mockMvc.perform(post("/api/archives")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(dto)))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.id").value(1))
            .andDo(print());
    }
    
    @Test
    @DisplayName("POST /api/archives - 标题为空应返回400")
    @WithMockUser(username = "testuser", roles = {"ADMIN"})
    void createArchive_EmptyTitle_ShouldReturn400() throws Exception {
        // Given
        ArchiveCreateDTO dto = ArchiveCreateDTO.builder()
            .title("")  // 空标题
            .categoryId(1L)
            .build();
        
        // When & Then
        mockMvc.perform(post("/api/archives")
                .contentType(MediaType.APPLICATION_JSON)
                .content(objectMapper.writeValueAsString(dto)))
            .andExpect(status().isBadRequest())
            .andExpect(jsonPath("$.code").value(400))
            .andDo(print());
    }
}
```

#### 3.5.2 Repository层测试

**测试重点**：
- CRUD操作
- 自定义查询
- 分页排序
- 事务处理

**示例**：

```java
@DisplayName("档案Repository测试")
@DataJpaTest
class ArchiveRepositoryTest extends BaseTest {
    
    @Autowired
    private ArchiveRepository archiveRepository;
    
    @Test
    @DisplayName("保存并查询档案")
    void saveAndFindArchive() {
        // Given
        Archive archive = createTestArchive("测试档案");
        
        // When
        Archive saved = archiveRepository.save(archive);
        Archive found = archiveRepository.findById(saved.getId()).orElse(null);
        
        // Then
        assertThat(found).isNotNull();
        assertThat(found.getTitle()).isEqualTo("测试档案");
    }
    
    @Test
    @DisplayName("根据分类查询档案")
    void findByCategoryId() {
        // Given
        Archive archive1 = createTestArchive("档案1");
        archive1.setCategoryId(1L);
        Archive archive2 = createTestArchive("档案2");
        archive2.setCategoryId(1L);
        Archive archive3 = createTestArchive("档案3");
        archive3.setCategoryId(2L);
        
        archiveRepository.saveAll(List.of(archive1, archive2, archive3));
        
        // When
        List<Archive> result = archiveRepository.findByCategoryId(1L);
        
        // Then
        assertThat(result).hasSize(2);
        assertThat(result).extracting(Archive::getTitle)
            .containsExactlyInAnyOrder("档案1", "档案2");
    }
    
    @Test
    @DisplayName("分页查询档案")
    void findAllWithPagination() {
        // Given
        for (int i = 1; i <= 15; i++) {
            Archive archive = createTestArchive("档案" + i);
            archiveRepository.save(archive);
        }
        
        // When
        Pageable pageable = PageRequest.of(0, 10, Sort.by("createTime").descending());
        Page<Archive> page = archiveRepository.findAll(pageable);
        
        // Then
        assertThat(page.getTotalElements()).isEqualTo(15);
        assertThat(page.getTotalPages()).isEqualTo(2);
        assertThat(page.getContent()).hasSize(10);
    }
}
```

### 3.6 测试配置

#### 3.6.1 application-test.yml

```yaml
spring:
  datasource:
    driver-class-name: org.h2.Driver
    url: jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
    username: sa
    password:
  
  jpa:
    hibernate:
      ddl-auto: create-drop
    show-sql: false
    properties:
      hibernate:
        format_sql: true
        dialect: org.hibernate.dialect.H2Dialect
  
  # 禁用RabbitMQ
  rabbitmq:
    host: localhost
    port: 5672
  autoconfigure:
    exclude:
      - org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration
  
  # 使用简单缓存
  cache:
    type: simple

# 日志配置
logging:
  level:
    com.archive.management: DEBUG
    org.springframework.test: INFO
    org.hibernate.SQL: WARN
```

#### 3.6.2 JaCoCo配置 (pom.xml)

```xml
<plugin>
    <groupId>org.jacoco</groupId>
    <artifactId>jacoco-maven-plugin</artifactId>
    <version>0.8.8</version>
    <executions>
        <execution>
            <goals>
                <goal>prepare-agent</goal>
            </goals>
        </execution>
        <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
                <goal>report</goal>
            </goals>
        </execution>
        <execution>
            <id>jacoco-check</id>
            <goals>
                <goal>check</goal>
            </goals>
            <configuration>
                <rules>
                    <rule>
                        <element>PACKAGE</element>
                        <limits>
                            <limit>
                                <counter>LINE</counter>
                                <value>COVEREDRATIO</value>
                                <minimum>0.80</minimum>
                            </limit>
                        </limits>
                    </rule>
                </rules>
            </configuration>
        </execution>
    </executions>
</plugin>
```

---

## 前端测试规范

### 4.1 技术栈

- **测试框架**: Vitest
- **组件测试**: Vue Test Utils
- **DOM环境**: happy-dom
- **覆盖率工具**: @vitest/coverage-v8
- **断言库**: Vitest内置 + Chai

### 4.2 项目结构

```
frontend/src/
├── test-utils/                      # 测试辅助工具
│   ├── index.ts                     # 通用测试工具
│   └── mocks.ts                     # Mock工具
├── utils/__tests__/                 # 工具函数测试
│   ├── formatter.spec.ts
│   ├── date.spec.ts
│   └── validation.spec.ts
├── stores/__tests__/                # Store测试
│   ├── user.spec.ts
│   ├── auth.spec.ts
│   └── app.spec.ts
├── components/__tests__/            # 组件测试
│   ├── common/
│   │   ├── DataTable.spec.ts
│   │   └── SearchBox.spec.ts
│   └── business/
│       ├── ArchiveForm.spec.ts
│       └── BorrowList.spec.ts
├── composables/__tests__/           # Composable测试
│   ├── usePermission.spec.ts
│   └── useExport.spec.ts
└── api/__tests__/                   # API模块测试
    ├── archive.spec.ts
    └── user.spec.ts
```

### 4.3 测试辅助工具

#### 4.3.1 test-utils/index.ts

```typescript
import { mount, VueWrapper } from '@vue/test-utils'
import type { ComponentPublicInstance } from 'vue'
import ElementPlus from 'element-plus'
import { createPinia } from 'pinia'

/**
 * 挂载组件的辅助函数
 * 自动注册Element Plus和Pinia
 */
export function mountWithPlugins(component: any, options: any = {}) {
  const pinia = createPinia()
  
  return mount(component, {
    global: {
      plugins: [ElementPlus, pinia],
      stubs: {
        teleport: true,
        transition: false
      },
      ...options.global
    },
    ...options
  })
}

/**
 * 等待异步更新
 */
export async function flushPromises() {
  return new Promise((resolve) => setTimeout(resolve, 0))
}

/**
 * 模拟用户输入
 */
export async function setInputValue(
  wrapper: VueWrapper<ComponentPublicInstance>,
  selector: string,
  value: string
) {
  const input = wrapper.find(selector)
  await input.setValue(value)
  await wrapper.vm.$nextTick()
}

/**
 * 模拟用户点击
 */
export async function clickButton(
  wrapper: VueWrapper<ComponentPublicInstance>,
  selector: string
) {
  const button = wrapper.find(selector)
  await button.trigger('click')
  await wrapper.vm.$nextTick()
}
```

#### 4.3.2 test-utils/mocks.ts

```typescript
import { vi } from 'vitest'

/**
 * 模拟localStorage
 */
export const mockLocalStorage = () => {
  const storage: Record<string, string> = {}
  
  return {
    getItem: vi.fn((key: string) => storage[key] || null),
    setItem: vi.fn((key: string, value: string) => {
      storage[key] = value
    }),
    removeItem: vi.fn((key: string) => {
      delete storage[key]
    }),
    clear: vi.fn(() => {
      Object.keys(storage).forEach(key => delete storage[key])
    })
  }
}

/**
 * 模拟axios请求
 */
export const mockAxios = () => {
  return {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
    request: vi.fn()
  }
}

/**
 * 模拟路由
 */
export const mockRouter = () => {
  return {
    push: vi.fn(),
    replace: vi.fn(),
    go: vi.fn(),
    back: vi.fn(),
    currentRoute: { value: { path: '/', query: {}, params: {} } }
  }
}

/**
 * 模拟Element Plus消息提示
 */
export const mockElMessage = () => {
  return {
    success: vi.fn(),
    error: vi.fn(),
    warning: vi.fn(),
    info: vi.fn()
  }
}
```

### 4.4 单元测试规范

#### 4.4.1 工具函数测试

**示例**：

```typescript
import { describe, it, expect } from 'vitest'
import { formatDate, formatFileSize, formatNumber } from '@/utils/formatter'

describe('formatter工具函数', () => {
  describe('formatDate', () => {
    it('应该正确格式化日期', () => {
      const date = new Date('2024-01-15T10:30:00Z')
      expect(formatDate(date, 'YYYY-MM-DD')).toBe('2024-01-15')
    })

    it('应该处理null值', () => {
      expect(formatDate(null)).toBe('')
    })

    it('应该支持自定义格式', () => {
      const date = new Date('2024-01-15T10:30:00Z')
      expect(formatDate(date, 'YYYY年MM月DD日')).toBe('2024年01月15日')
    })
  })

  describe('formatFileSize', () => {
    it('应该正确格式化字节', () => {
      expect(formatFileSize(0)).toBe('0 B')
      expect(formatFileSize(1024)).toBe('1 KB')
      expect(formatFileSize(1048576)).toBe('1 MB')
      expect(formatFileSize(1073741824)).toBe('1 GB')
    })

    it('应该保留两位小数', () => {
      expect(formatFileSize(1536)).toBe('1.50 KB')
      expect(formatFileSize(2621440)).toBe('2.50 MB')
    })
  })

  describe('formatNumber', () => {
    it('应该添加千分位分隔符', () => {
      expect(formatNumber(1000)).toBe('1,000')
      expect(formatNumber(1000000)).toBe('1,000,000')
    })

    it('应该处理小数', () => {
      expect(formatNumber(1234.56)).toBe('1,234.56')
    })
  })
})
```

#### 4.4.2 Store测试

**示例**：

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useUserStore } from '@/stores/user'

describe('User Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  describe('状态管理', () => {
    it('应该有正确的初始状态', () => {
      const store = useUserStore()
      
      expect(store.username).toBe('')
      expect(store.isLoggedIn).toBe(false)
      expect(store.userId).toBeNull()
      expect(store.roles).toEqual([])
    })

    it('应该能够更新用户信息', () => {
      const store = useUserStore()
      
      store.setUser({
        id: 1,
        username: 'testuser',
        roles: ['ADMIN']
      })
      
      expect(store.userId).toBe(1)
      expect(store.username).toBe('testuser')
      expect(store.roles).toEqual(['ADMIN'])
      expect(store.isLoggedIn).toBe(true)
    })
  })

  describe('Actions', () => {
    it('登录应该更新状态', async () => {
      const store = useUserStore()
      
      await store.login('testuser', 'password123')
      
      expect(store.isLoggedIn).toBe(true)
      expect(store.username).toBe('testuser')
    })

    it('登出应该清空状态', async () => {
      const store = useUserStore()
      
      // 先登录
      await store.login('testuser', 'password123')
      expect(store.isLoggedIn).toBe(true)
      
      // 再登出
      await store.logout()
      
      expect(store.isLoggedIn).toBe(false)
      expect(store.username).toBe('')
      expect(store.userId).toBeNull()
    })
  })

  describe('Getters', () => {
    it('displayName应该返回正确的显示名称', () => {
      const store = useUserStore()
      
      // 未登录时
      expect(store.displayName).toBe('游客')
      
      // 登录后
      store.setUser({ id: 1, username: 'testuser', roles: [] })
      expect(store.displayName).toBe('testuser')
    })

    it('hasRole应该正确判断角色', () => {
      const store = useUserStore()
      store.setUser({ id: 1, username: 'testuser', roles: ['ADMIN', 'USER'] })
      
      expect(store.hasRole('ADMIN')).toBe(true)
      expect(store.hasRole('USER')).toBe(true)
      expect(store.hasRole('GUEST')).toBe(false)
    })
  })
})
```

### 4.5 组件测试规范

#### 4.5.1 通用组件测试

**示例 - DataTable组件**：

```typescript
import { describe, it, expect, vi } from 'vitest'
import { mountWithPlugins } from '@/test-utils'
import DataTable from '@/components/common/DataTable.vue'

describe('DataTable组件', () => {
  const mockData = [
    { id: 1, name: '张三', age: 25 },
    { id: 2, name: '李四', age: 30 }
  ]

  const mockColumns = [
    { prop: 'id', label: 'ID', width: 80 },
    { prop: 'name', label: '姓名', width: 120 },
    { prop: 'age', label: '年龄', width: 100 }
  ]

  it('应该正确渲染表格数据', () => {
    const wrapper = mountWithPlugins(DataTable, {
      props: {
        data: mockData,
        columns: mockColumns
      }
    })

    expect(wrapper.find('.el-table').exists()).toBe(true)
    expect(wrapper.text()).toContain('张三')
    expect(wrapper.text()).toContain('李四')
  })

  it('应该支持分页', async () => {
    const onPageChange = vi.fn()
    
    const wrapper = mountWithPlugins(DataTable, {
      props: {
        data: mockData,
        columns: mockColumns,
        pagination: {
          total: 100,
          pageSize: 10,
          currentPage: 1
        },
        onPageChange
      }
    })

    expect(wrapper.find('.el-pagination').exists()).toBe(true)
    
    // 模拟翻页
    await wrapper.find('.el-pagination .btn-next').trigger('click')
    expect(onPageChange).toHaveBeenCalledWith(2)
  })

  it('应该支持行选择', async () => {
    const onSelectionChange = vi.fn()
    
    const wrapper = mountWithPlugins(DataTable, {
      props: {
        data: mockData,
        columns: mockColumns,
        selectable: true,
        onSelectionChange
      }
    })

    // 模拟选择行
    const checkbox = wrapper.find('.el-table__row:first-child .el-checkbox')
    await checkbox.trigger('click')
    
    expect(onSelectionChange).toHaveBeenCalled()
  })

  it('应该支持自定义操作列', () => {
    const wrapper = mountWithPlugins(DataTable, {
      props: {
        data: mockData,
        columns: mockColumns
      },
      slots: {
        actions: '<button class="edit-btn">编辑</button>'
      }
    })

    expect(wrapper.find('.edit-btn').exists()).toBe(true)
  })
})
```

#### 4.5.2 业务组件测试

**示例 - ArchiveForm组件**：

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mountWithPlugins, setInputValue, clickButton } from '@/test-utils'
import ArchiveForm from '@/components/business/ArchiveForm.vue'
import * as archiveApi from '@/api/modules/archive'

vi.mock('@/api/modules/archive')

describe('ArchiveForm组件', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it('应该正确渲染表单', () => {
    const wrapper = mountWithPlugins(ArchiveForm, {
      props: {
        visible: true
      }
    })

    expect(wrapper.find('.archive-form').exists()).toBe(true)
    expect(wrapper.find('input[placeholder="请输入档案标题"]').exists()).toBe(true)
    expect(wrapper.find('textarea[placeholder="请输入档案内容"]').exists()).toBe(true)
  })

  it('应该验证必填字段', async () => {
    const wrapper = mountWithPlugins(ArchiveForm, {
      props: {
        visible: true
      }
    })

    // 不填写任何内容，直接提交
    await clickButton(wrapper, '.submit-btn')

    // 应该显示验证错误
    expect(wrapper.text()).toContain('请输入档案标题')
  })

  it('应该成功提交表单', async () => {
    const mockCreate = vi.fn().mockResolvedValue({ id: 1 })
    vi.mocked(archiveApi.createArchive).mockImplementation(mockCreate)

    const onSuccess = vi.fn()
    
    const wrapper = mountWithPlugins(ArchiveForm, {
      props: {
        visible: true,
        onSuccess
      }
    })

    // 填写表单
    await setInputValue(wrapper, 'input[placeholder="请输入档案标题"]', '测试档案')
    await setInputValue(wrapper, 'textarea[placeholder="请输入档案内容"]', '档案内容')

    // 提交
    await clickButton(wrapper, '.submit-btn')
    await flushPromises()

    // 验证API调用
    expect(mockCreate).toHaveBeenCalledWith({
      title: '测试档案',
      content: '档案内容'
    })

    // 验证成功回调
    expect(onSuccess).toHaveBeenCalled()
  })

  it('应该处理提交失败', async () => {
    const mockCreate = vi.fn().mockRejectedValue(new Error('创建失败'))
    vi.mocked(archiveApi.createArchive).mockImplementation(mockCreate)

    const wrapper = mountWithPlugins(ArchiveForm, {
      props: {
        visible: true
      }
    })

    // 填写并提交
    await setInputValue(wrapper, 'input[placeholder="请输入档案标题"]', '测试档案')
    await clickButton(wrapper, '.submit-btn')
    await flushPromises()

    // 应该显示错误消息
    expect(wrapper.text()).toContain('创建失败')
  })

  it('应该支持编辑模式', async () => {
    const mockUpdate = vi.fn().mockResolvedValue({ id: 1 })
    vi.mocked(archiveApi.updateArchive).mockImplementation(mockUpdate)

    const wrapper = mountWithPlugins(ArchiveForm, {
      props: {
        visible: true,
        mode: 'edit',
        data: {
          id: 1,
          title: '原标题',
          content: '原内容'
        }
      }
    })

    // 验证表单已填充数据
    expect(wrapper.find('input[placeholder="请输入档案标题"]').element.value).toBe('原标题')

    // 修改标题
    await setInputValue(wrapper, 'input[placeholder="请输入档案标题"]', '新标题')
    await clickButton(wrapper, '.submit-btn')
    await flushPromises()

    // 验证调用更新API
    expect(mockUpdate).toHaveBeenCalledWith(1, {
      title: '新标题',
      content: '原内容'
    })
  })
})
```

### 4.6 Composable测试

**示例 - usePermission**：

```typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { usePermission } from '@/composables/usePermission'
import { useUserStore } from '@/stores/user'

describe('usePermission', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })

  it('应该正确检查权限', () => {
    const userStore = useUserStore()
    userStore.setUser({
      id: 1,
      username: 'testuser',
      permissions: ['archive:read', 'archive:create']
    })

    const { hasPermission } = usePermission()

    expect(hasPermission('archive:read')).toBe(true)
    expect(hasPermission('archive:create')).toBe(true)
    expect(hasPermission('archive:delete')).toBe(false)
  })

  it('应该支持多权限检查（AND）', () => {
    const userStore = useUserStore()
    userStore.setUser({
      id: 1,
      username: 'testuser',
      permissions: ['archive:read', 'archive:create']
    })

    const { hasAllPermissions } = usePermission()

    expect(hasAllPermissions(['archive:read', 'archive:create'])).toBe(true)
    expect(hasAllPermissions(['archive:read', 'archive:delete'])).toBe(false)
  })

  it('应该支持多权限检查（OR）', () => {
    const userStore = useUserStore()
    userStore.setUser({
      id: 1,
      username: 'testuser',
      permissions: ['archive:read']
    })

    const { hasAnyPermission } = usePermission()

    expect(hasAnyPermission(['archive:read', 'archive:delete'])).toBe(true)
    expect(hasAnyPermission(['archive:create', 'archive:delete'])).toBe(false)
  })
})
```

### 4.7 测试配置

#### 4.7.1 vitest.config.ts

```typescript
import { defineConfig, mergeConfig } from 'vite'
import { configDefaults } from 'vitest/config'
import viteConfig from './vite.config'

export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      environment: 'happy-dom',
      globals: true,
      include: ['src/**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
      exclude: [...configDefaults.exclude, 'e2e/*'],
      coverage: {
        provider: 'v8',
        reporter: ['text', 'json', 'html', 'lcov'],
        reportsDirectory: './coverage',
        exclude: [
          ...configDefaults.exclude,
          'src/main.ts',
          'src/**/*.d.ts',
          'src/**/*.config.*',
          'src/router/index.ts'
        ],
        thresholds: {
          lines: 70,
          functions: 70,
          branches: 70,
          statements: 70
        }
      },
      testTimeout: 10000,
      hookTimeout: 10000
    }
  })
)
```

---

## 测试编写指南

### 5.1 测试结构 - AAA模式

所有测试都应遵循 **Arrange-Act-Assert (AAA)** 模式：

```java
@Test
void testMethodName() {
    // Arrange (Given): 准备测试数据和环境
    User user = createTestUser("testuser");
    when(userRepository.findById(1L)).thenReturn(Optional.of(user));
    
    // Act (When): 执行被测试的方法
    User result = userService.getUserById(1L);
    
    // Assert (Then): 验证结果
    assertThat(result).isNotNull();
    assertThat(result.getUsername()).isEqualTo("testuser");
}
```

### 5.2 测试命名规范

#### 5.2.1 后端测试命名

**格式**: `methodName_scenario_expectedBehavior`

**示例**：
```java
// ✅ 好的命名
createArchive_ValidData_ShouldReturnSavedArchive()
createArchive_EmptyTitle_ShouldThrowValidationException()
deleteArchive_NoPermission_ShouldThrowPermissionDeniedException()

// ❌ 不好的命名
testCreate()
test1()
createArchiveTest()
```

#### 5.2.2 前端测试命名

**格式**: 使用中文描述，清晰表达测试意图

**示例**：
```typescript
// ✅ 好的命名
it('应该正确渲染表格数据')
it('应该在标题为空时显示验证错误')
it('应该成功提交表单并调用API')

// ❌ 不好的命名
it('test1')
it('renders')
it('works')
```

### 5.3 断言最佳实践

#### 5.3.1 后端断言

**使用AssertJ流式断言**：

```java
// ✅ 推荐：使用AssertJ
assertThat(result).isNotNull();
assertThat(result.getId()).isEqualTo(1L);
assertThat(result.getTitle()).isEqualTo("测试档案");
assertThat(result.getStatus()).isIn(ArchiveStatus.DRAFT, ArchiveStatus.PUBLISHED);

// ✅ 推荐：链式断言
assertThat(result)
    .isNotNull()
    .extracting(Archive::getTitle, Archive::getStatus)
    .containsExactly("测试档案", ArchiveStatus.DRAFT);

// ❌ 不推荐：使用JUnit断言
assertEquals(1L, result.getId());
assertTrue(result.getTitle().equals("测试档案"));
```

**集合断言**：

```java
List<Archive> archives = archiveService.findAll();

assertThat(archives)
    .isNotEmpty()
    .hasSize(3)
    .extracting(Archive::getTitle)
    .containsExactlyInAnyOrder("档案1", "档案2", "档案3");
```

**异常断言**：

```java
// ✅ 推荐：使用assertThatThrownBy
assertThatThrownBy(() -> archiveService.create(null))
    .isInstanceOf(ValidationException.class)
    .hasMessageContaining("标题不能为空");

// ❌ 不推荐：使用@Test(expected)
@Test(expected = ValidationException.class)
void testCreate() {
    archiveService.create(null);
}
```

#### 5.3.2 前端断言

```typescript
// ✅ 基本断言
expect(result).toBe(expected)
expect(result).toEqual(expected)
expect(result).toBeTruthy()
expect(result).toBeFalsy()

// ✅ 数组断言
expect(array).toHaveLength(3)
expect(array).toContain(item)
expect(array).toEqual(expect.arrayContaining([1, 2, 3]))

// ✅ 对象断言
expect(obj).toHaveProperty('name', 'test')
expect(obj).toMatchObject({ name: 'test', age: 25 })

// ✅ DOM断言
expect(wrapper.find('.title').text()).toBe('测试标题')
expect(wrapper.find('.button').exists()).toBe(true)
expect(wrapper.classes()).toContain('active')
```

### 5.4 Mock使用指南

#### 5.4.1 后端Mock

**Service层Mock Repository**：

```java
@MockBean
private ArchiveRepository archiveRepository;

@Test
void testFindById() {
    // Given
    Archive archive = createTestArchive("测试档案");
    when(archiveRepository.findById(1L)).thenReturn(Optional.of(archive));
    
    // When
    Archive result = archiveService.findById(1L);
    
    // Then
    assertThat(result).isEqualTo(archive);
    verify(archiveRepository, times(1)).findById(1L);
}
```

**Mock静态方法**：

```java
@Test
void testWithStaticMethod() {
    try (MockedStatic<DateUtil> mockedStatic = mockStatic(DateUtil.class)) {
        mockedStatic.when(() -> DateUtil.now()).thenReturn(LocalDateTime.of(2024, 1, 1, 0, 0));
        
        // 测试逻辑
        LocalDateTime result = DateUtil.now();
        assertThat(result).isEqualTo(LocalDateTime.of(2024, 1, 1, 0, 0));
    }
}
```

#### 5.4.2 前端Mock

**Mock API调用**：

```typescript
import { vi } from 'vitest'
import * as archiveApi from '@/api/modules/archive'

vi.mock('@/api/modules/archive')

it('应该调用API创建档案', async () => {
  const mockCreate = vi.fn().mockResolvedValue({ id: 1 })
  vi.mocked(archiveApi.createArchive).mockImplementation(mockCreate)
  
  await archiveService.create({ title: '测试' })
  
  expect(mockCreate).toHaveBeenCalledWith({ title: '测试' })
})
```

**Mock localStorage**：

```typescript
import { mockLocalStorage } from '@/test-utils/mocks'

it('应该保存数据到localStorage', () => {
  const storage = mockLocalStorage()
  Object.defineProperty(window, 'localStorage', { value: storage })
  
  // 测试逻辑
  localStorage.setItem('token', 'abc123')
  
  expect(storage.setItem).toHaveBeenCalledWith('token', 'abc123')
})
```

### 5.5 测试数据准备

#### 5.5.1 使用测试数据工厂

**后端**：

```java
public class TestDataFactory {
    
    public static User createUser(String username) {
        return User.builder()
            .username(username)
            .password("password123")
            .email(username + "@test.com")
            .status(UserStatus.ACTIVE)
            .build();
    }
    
    public static Archive createArchive(String title, User creator) {
        return Archive.builder()
            .title(title)
            .content("测试内容")
            .categoryId(1L)
            .creator(creator)
            .status(ArchiveStatus.DRAFT)
            .build();
    }
}
```

**前端**：

```typescript
// test-utils/factories.ts
export function createMockUser(overrides = {}) {
  return {
    id: 1,
    username: 'testuser',
    email: 'test@example.com',
    roles: ['USER'],
    ...overrides
  }
}

export function createMockArchive(overrides = {}) {
  return {
    id: 1,
    title: '测试档案',
    content: '测试内容',
    categoryId: 1,
    status: 'DRAFT',
    ...overrides
  }
}
```

---

## 最佳实践

### 6.1 测试独立性

✅ **每个测试应该独立运行**：

```java
// ✅ 好的做法：每个测试独立准备数据
@Test
void test1() {
    User user = createTestUser("user1");
    // 测试逻辑
}

@Test
void test2() {
    User user = createTestUser("user2");
    // 测试逻辑
}

// ❌ 不好的做法：测试之间共享状态
private User sharedUser;

@BeforeEach
void setup() {
    sharedUser = createTestUser("shared");
}

@Test
void test1() {
    sharedUser.setName("Modified");  // 影响其他测试
}
```

### 6.2 测试可读性

✅ **使用有意义的变量名和注释**：

```java
// ✅ 好的做法
@Test
void createArchive_WhenUserHasPermission_ShouldSucceed() {
    // Given: 准备有权限的用户和档案数据
    User authorizedUser = createUserWithPermission("archive:create");
    ArchiveCreateDTO validArchiveData = createValidArchiveDTO();
    
    // When: 执行创建操作
    Archive result = archiveService.create(validArchiveData, authorizedUser);
    
    // Then: 验证档案创建成功
    assertThat(result.getId()).isNotNull();
    assertThat(result.getCreator()).isEqualTo(authorizedUser);
}

// ❌ 不好的做法
@Test
void test1() {
    User u = new User();
    Archive a = new Archive();
    Archive r = service.create(a, u);
    assertNotNull(r);
}
```

### 6.3 避免测试脆弱性

✅ **不要依赖执行顺序**：

```java
// ❌ 不好的做法：依赖测试执行顺序
@Test
@Order(1)
void createUser() {
    userService.create(user);
}

@Test
@Order(2)
void updateUser() {
    userService.update(user);  // 依赖test1
}

// ✅ 好的做法：每个测试独立
@Test
void updateUser() {
    User user = userService.create(createTestUser());
    user.setName("Updated");
    userService.update(user);
}
```

### 6.4 测试覆盖关键路径

✅ **优先测试核心业务逻辑**：

```java
// ✅ 必须测试的场景
@Test void createArchive_ValidData_Success() { }
@Test void createArchive_EmptyTitle_ThrowsException() { }
@Test void createArchive_NoPermission_ThrowsException() { }
@Test void createArchive_DuplicateTitle_ThrowsException() { }

// 可选测试的场景
@Test void createArchive_VeryLongTitle_Success() { }
@Test void createArchive_SpecialCharacters_Success() { }
```

### 6.5 合理使用参数化测试

✅ **减少重复代码**：

```java
// ✅ 好的做法：使用参数化测试
@ParameterizedTest
@CsvSource({
    "2024-01-15, yyyy-MM-dd, 2024-01-15",
    "2024/01/15, yyyy/MM/dd, 2024-01-15",
    "20240115, yyyyMMdd, 2024-01-15"
})
void parseDate_VariousFormats(String input, String pattern, String expected) {
    LocalDate result = DateUtil.parse(input, pattern);
    assertThat(result.toString()).isEqualTo(expected);
}

// ❌ 不好的做法：重复的测试
@Test void parseDate_Format1() { }
@Test void parseDate_Format2() { }
@Test void parseDate_Format3() { }
```

### 6.6 测试性能考虑

✅ **避免不必要的等待**：

```typescript
// ❌ 不好的做法：使用固定延迟
await new Promise(resolve => setTimeout(resolve, 1000))

// ✅ 好的做法：使用flushPromises
await flushPromises()

// ✅ 好的做法：使用vi.useFakeTimers
vi.useFakeTimers()
// 测试逻辑
vi.advanceTimersByTime(1000)
vi.useRealTimers()
```

---

## 代码覆盖率要求

### 7.1 覆盖率目标

| 模块 | 行覆盖率 | 分支覆盖率 | 函数覆盖率 | 截止时间 |
|------|---------|-----------|-----------|----------|
| 后端核心业务 | ≥85% | ≥80% | ≥85% | 第5周末 |
| 后端工具类 | ≥90% | ≥85% | ≥90% | 第4周末 |
| 前端核心组件 | ≥75% | ≥70% | ≥75% | 第5周末 |
| 前端工具函数 | ≥85% | ≥80% | ≥85% | 第4周末 |

### 7.2 覆盖率排除项

**后端排除**：
- 配置类 (`*Config.java`)
- 实体类 (`entity/*.java`)
- DTO类 (`dto/*.java`)
- 常量类 (`*Constants.java`)
- 启动类 (`*Application.java`)

**前端排除**：
- 配置文件 (`*.config.ts`)
- 类型定义 (`*.d.ts`)
- 路由配置 (`router/index.ts`)
- 主入口 (`main.ts`)

### 7.3 覆盖率报告查看

**后端**：
```bash
# 生成覆盖率报告
mvn clean test

# 查看HTML报告
open target/site/jacoco/index.html
```

**前端**：
```bash
# 生成覆盖率报告
npm run test:coverage

# 查看HTML报告
open coverage/index.html
```

---

## 测试命名规范

### 8.1 测试类命名

**后端**：
```java
// 单元测试
ArchiveServiceTest
UserServiceTest
DateUtilTest

// 集成测试
ArchiveControllerTest
ArchiveRepositoryTest
ArchiveIntegrationTest
```

**前端**：
```typescript
// 文件命名
formatter.spec.ts
user.spec.ts
DataTable.spec.ts
```

### 8.2 测试方法命名

**后端 - 使用@DisplayName**：
```java
@Test
@DisplayName("创建档案 - 成功场景")
void createArchive_Success() { }

@Test
@DisplayName("创建档案 - 标题为空应抛出异常")
void createArchive_EmptyTitle_ShouldThrowException() { }
```

**前端 - 使用中文描述**：
```typescript
describe('档案表单', () => {
  it('应该正确渲染表单')
  it('应该验证必填字段')
  it('应该成功提交表单')
})
```

---

## Mock与Stub使用指南

### 9.1 何时使用Mock

✅ **应该Mock的场景**：
- 外部API调用
- 数据库操作（在单元测试中）
- 文件系统操作
- 网络请求
- 第三方服务
- 时间相关操作

❌ **不应该Mock的场景**：
- 被测试的类本身
- 简单的POJO对象
- 工具类（应该测试真实实现）

### 9.2 Mock vs Stub

**Mock**: 验证交互（方法是否被调用）
```java
verify(mockRepository, times(1)).save(any());
```

**Stub**: 提供预定义的返回值
```java
when(mockRepository.findById(1L)).thenReturn(Optional.of(archive));
```

---

## CI/CD集成

### 10.1 GitHub Actions配置

详见任务1.4的CI/CD配置部分。

### 10.2 测试失败处理

1. **本地运行测试**：确保所有测试通过
2. **查看CI日志**：定位失败原因
3. **修复问题**：修复代码或测试
4. **重新提交**：触发CI重新运行

---

## 常见问题与解决方案

### 11.1 后端常见问题

#### Q1: H2数据库初始化失败
**解决方案**：
```yaml
# application-test.yml
spring:
  datasource:
    url: jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1
  jpa:
    hibernate:
      ddl-auto: create-drop
```

#### Q2: 测试之间相互影响
**解决方案**：
- 使用`@Transactional`自动回滚
- 在`@AfterEach`中清理数据
- 确保测试独立性

#### Q3: Mock不生效
**解决方案**：
```java
// 确保使用@MockBean而不是@Mock
@MockBean
private UserRepository userRepository;

// 确保when-then在测试方法内部
@Test
void test() {
    when(userRepository.findById(1L)).thenReturn(...);
    // 测试逻辑
}
```

### 11.2 前端常见问题

#### Q1: 组件找不到
**解决方案**：
```typescript
// 使用mountWithPlugins自动注册插件
const wrapper = mountWithPlugins(MyComponent)

// 或手动注册
const wrapper = mount(MyComponent, {
  global: {
    plugins: [ElementPlus]
  }
})
```

#### Q2: 异步测试不稳定
**解决方案**：
```typescript
// 使用flushPromises等待异步操作
await clickButton(wrapper, '.submit-btn')
await flushPromises()

// 或使用waitFor
await waitFor(() => {
  expect(wrapper.text()).toContain('成功')
})
```

#### Q3: Mock不生效
**解决方案**：
```typescript
// 确保在测试文件顶部mock
vi.mock('@/api/modules/archive')

// 在测试中实现mock
vi.mocked(archiveApi.createArchive).mockResolvedValue({ id: 1 })
```

---

## 附录

### 附录A: 测试检查清单

**提交代码前检查**：
- [ ] 所有测试通过
- [ ] 新增代码有对应测试
- [ ] 覆盖率达标
- [ ] 测试命名规范
- [ ] 无重复测试
- [ ] 测试独立运行
- [ ] Mock使用合理
- [ ] 断言清晰明确

### 附录B: 常用命令

**后端**：
```bash
# 运行所有测试
mvn clean test

# 运行指定测试类
mvn test -Dtest=ArchiveServiceTest

# 运行指定测试方法
mvn test -Dtest=ArchiveServiceTest#createArchive_Success

# 生成覆盖率报告
mvn clean test jacoco:report

# 跳过测试
mvn clean install -DskipTests
```

**前端**：
```bash
# 运行所有测试
npm run test

# 监听模式
npm run test:watch

# UI模式
npm run test:ui

# 生成覆盖率
npm run test:coverage

# 运行指定文件
npm run test formatter.spec.ts
```

### 附录C: 参考资源

**后端**：
- [JUnit 5 官方文档](https://junit.org/junit5/docs/current/user-guide/)
- [Mockito 官方文档](https://javadoc.io/doc/org.mockito/mockito-core/latest/org/mockito/Mockito.html)
- [AssertJ 官方文档](https://assertj.github.io/doc/)
- [Spring Boot Testing](https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.testing)

**前端**：
- [Vitest 官方文档](https://vitest.dev/)
- [Vue Test Utils 官方文档](https://test-utils.vuejs.org/)
- [Testing Library](https://testing-library.com/)

---

**文档版本**: v1.0  
**最后更新**: 2025年10月15日  
**维护人**: 开发团队  
**审核状态**: 待审核

